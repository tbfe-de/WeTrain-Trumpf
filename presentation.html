<!DOCTYPE html>
<html>
  <head>
    <title>Trumpf-Laser C++11 / Boost</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
    <!-- when changing the stylesheet file please see also remark below -->
    <link rel="stylesheet" type="text/css" href="CSS/styling.css" />
  </head>
  <body>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- :::::::::: template pages come first ... skip to REALCONTENT ::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<textarea id="source">

layout: true
name: blank
styling: styling.css
styling-by: Martin Weitzel

<!--
  *****************************************************************************
  Template used for title page (only)
  *****************************************************************************
  Please change the 'styling-by:' attribute if you change the style-sheet.
-->

.stylehint[
Styled with [{{styling}}]({{styling}}) by {{styling-by}}
]

---
layout: true
name: plain
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages NOT referring to any Info-Graphic
  *****************************************************************************
  The following attributes are mandatory FOR THE TEMPLATE PAGE and should
  simply be left empty if not meaningful.

  copyright: will be reproduced in each page footer first
  branding: will reproduced in each page footer next
  customer: will be reproduced in each page footer last

  As the above attributes are part of several page templates a global replace
  should be used for consistent changes.

  On pages USING THIS TEMPLATE the following attributes must be set:

  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: linkinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for for pages INTRODUCING to a new Info-Graphic
  *****************************************************************************
  On this kind of pages a size-reduced version of the whole info graphic will
  be reproduced and occupies approximately 2/3 of the page width. So only add
  little information, preferably links to later pages dealing with single
  sections of the info graphic.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the infographic EXCLUDING the suffix.
  header: ## and header text (i.e. including the markdown formatting indicator)

-->

{{header}}

.infographic[
[![Info-Grafik](InfoGraphics/{{graphic}}.png)](InfoGraphics/{{graphic}}.png
                "Click to open – add [CTRL+] SHIFT for new [tabbed] window")
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

---
layout: true
name: withinfo
copyright: (CC) BY-SA
branding:  [Dipl.-Ing. Martin Weitzel](http://tbfe.de)
customer:  [im Auftrag von MicroConsult Training & Consulting GmbH](http://microconsult.de)

<!--
  *****************************************************************************
  Template used for pages dealing with a SPECIFIC SECTION of an Info-Graphic
  *****************************************************************************
  On such pages a link to the info graphic is reproduced in the top-right
  corner (or maybe elsewhere depending on the style sheet), so there are no
  restrictions with respect to the space available for the content of the page.

  On pages USING THIS TEMPLATE the following attributes must be set:

  graphic: file path to of the info graphic EXCLUDING the suffix and
  section: specific section in the info graphic this page refers to
  header: ## and header text (i.e. including the markdown formatting indicator)
-->

{{header}}

.infolink.right[
[Click here for Info-Graphic  
{{graphic}}](InfoGraphics/{{graphic}}.png "add [CTRL+] SHIFT for own [tabbed] window")  
{{section}}
]

.pagefooter[
{{copyright}}: {{branding}} {{customer}} .microconsult-logo[]
]

<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- end of templates ... below comes the REALCONTENT - TNETNOCLAER ends it -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
---
template: blank
name: frontmatter

.title[
	[Trumpf-Laser C++11 / Boost](#online_version)
]

.subtitle[
	Using C++11, the Language,  
        the Standard Library, and  
	selected parts from Boost
]
.author.pull-left[
	Durchführung:  
	Dipl.-Ing. Martin Weitzel  
	Technische Beratung für EDV  
	http://tbfe.de  
]
.client.pull-right[
	Im Auftrag von:  
	MicroConsult  
	Training & Consulting GmbH  
	http://www.microconsult.com
]

---
template: plain
class: agenda
name: agenda
header: ## Agenda

Topics._[] Monday to Friday (last day course ends after lunch-break)

------------------------------------------------------------------------------

1. [C++11 Extensions (and some related Boost)	](#cpp11_extensions)
1. [Exceptions (including Boost.Exception)	](#cpp11_and_boost_exceptions)
1. [STL Quick Tour (and some more of Boost)	](#stl_quickly_and some_boost)
1. [Strings (including Regular Expressions)	](#strings_and_regex)
1. [I/O-Streams (and even more of Boost))	](#std_iostreams_more_boost)
1. [C++11 Random Numbers			](#random_numbers)
1. [C++11 Durations and Time Points		](#cpp11_chrono))
1. [C++11 Multi-Threading			](#cpp11_multithreading)
1. [C++11 Tuple / Boost Optional, Variant, Any	](#cpp11_tuples_more_boost)
1. [C++11 Smart Pointers			](#cpp11_smart_pointers)
1. [More (Parts of) Boost			](#more_of_boost)

---

template: plain
name: online_version
header: ## Online Version of this Presentation

  [Creative Commons]: http://de.creativecommons.org/was-ist-cc

For all forms of redistribution a [Creative Commons]-license applies:

.I[[
**(CC) BY-SA**:  
Namensnennung und Weitergabe unter gleichen Bedingungen
](http://creativecommons.org/licenses/by-sa/3.0/de/)]

.W[
The content was produced and checked with adequate care.
The author may not be held liable for any errors or inaccuracies still contained.
]

You are welcome to point out errors or propose general improvements.

---
template: plain
header: ### Online References

C++ has become a huge topic so it will frequently be necessary to lookup
details in an online reference.

As general C++ reference the following can be recommended:

* http://en.cppreference.com/w/ - totally free, seems to be run by enthusiasts
  and now includes even [live examples](#online_compilation)

* http://www.cplusplus.com/ - obviously financed by moderate pop-ups,
  nevertheless well organized and up-to-date

For topics specific to boost:

* http://www.boost.org - The Official Boost Site

* http://en.highscore.de/cpp/boost/frontpage.html  
  A free Online Book._[] by Boris Schäling in English Language and

* http://www.highscore.de/cpp/boost - same in German Language 

.F[:
Some of the following pages will refer to a chapter or section in their top-right
corner, so you may want to keep the table of content of this book open in a browser
tab.
]

---
template: plain
header: ### Presentation

  [JavaScript]:    http://de.wikipedia.org/wiki/JavaScript
  [Modern CSS]:    http://www.w3.org/Style/CSS
  [CSS knowledge]: http://www.w3schools.com/css

This presentation uses a free HTML5-based slide-show tool named [`remark`](http://remarkjs.com).

#### Viewing

You may use any recent browser of your choice.

* [JavaScript] must be enabled.
* [Modern CSS] should be supported.._[]
* Cookies are **not** used.

.F[:
Given an appropriate level of [CSS knowledge] you may be able to tweak the
appearance.
]

---
template: plain
header: ### Following Links

Many clickable links have been provided in the hope they will give the online
version an added value over the print-outs you received.

.I[
You may want to follow links when viewing this presentation by **clicking with the
CTRL-key held** down, what will open the target document in a separate browser tab.
]

**And because the German Law seems to require it here is the usual disclaimer:**

YOU UNDERSTAND AND AGREE THAT UNDER NO CIRCUMSTANCES NEITHER THE AUTHOR OF THIS
DOCUMENT NOR THE COMPANY OR ANY ONE ELSE WHO MADE IT ACCESSIBLE TO YOU CAN BE
HELD RESPONSIBLE FOR THE CONTENT OF A FOREIGN SITE THAT IS DISPLAYED AFTER
CLICKING A LINK PROVIDED HERE.

---
template: plain
header: #### Prepared Printouts

Attendees of a training will receive a printed version of this document.

.I[
You may access a final electronic version including recent changes made during
this training or later via download.
]

#### DIY Printouts

  [Chrome Browser]: https://www.google.de/chrome/browser/desktop/

Also, with Google's [Chrome Browser] you can create a PDF any time:

* Using *Print To File* applies a special style suitable for DIN A4
  print-outs in portrait, with the lower half of each page for your notes.

* Notes contained in the presentation **will currently not be printed**.._[]

.F[:
That option may become available in a future version.
]

---
template: plain
name: annotations
header: #### Private Annotations

The core content of this HTML file is written in readable [markdown format].._[]

.F[:
With minor extensions, if you happen to know markdown already.
]

You have the option to handle this document by purely electronic means,
*including private annotations* you may want to add.

1. Save the HTML files of the presentation locally.

2. Add annotations with a text editor of your choice.

When viewing the document in a browser you may chose to view your annotations by
changing to *presenter's mode* with the `p` key.

* **You may try it out right now - back to normal is also with `p`.**

.I[
Future versions of this presentation **may or may not** use the notes section for
their own purposes - but in any case it should be possible to merge your private
annotations with a [diff-tool].
]

  [markdown format]: http://de.wikipedia.org/wiki/Markdown
  [diff-tool]:       http://de.wikipedia.org/wiki/Diff

???
The content structure of the HTML file is as follows:
````````````````````````````````````````````````````
        (some lines of HTML leader)
        <textarea>
        …
        … first presentation page …
        …
        ---
        … second presentation page …
        ---
        …
        … (etc.)
        …
        ---
        …
        … last presentation page …
        …
        &lt;/textarea>
        (some lines of HTML trailer)
````````````````````````````````````````````````````

Lines consisting of **exactly three minus signs** (nothing else!) are page
separators.

Annotations are shown in *Presenter's View* only and must be separated from
the slide content with a line consisting of **exactly three question marks**.
```
        …
        ---
        …
        … presentation slide content …
        …
        ???
        …
        … annotations added by you …
        …
        ---
        …
```

BTW: The easiest way to include small code examples, what might be a typical
use case for private annotations, is to just indent them by four spaces -
surrounding code fragments with lines of three or more back-ticks, a markdown
extension known as [Fenced Code Blocks], is the other option.

    #include <iostream>
    int main() {
        std::cout << "hello, world\n";
    }

[Fenced Code Blocks]: https://help.github.com/articles/github-flavored-markdown#fenced-code-blocks

As we are at it go: when you have this page loaded in a text editor, with the line
above - **not displayed** when you view this in the browser - and the paragraph
before the code example you have a nice way how to embed links without making
the text flow unreadable or inconvenient to edit.

<!-- The reference in square brackets needs to be unique only within a single slide
     and the line connecting the reference with the external link may be placed
     anywhere in the page … and HTML comments are another way to annotate,
     not even visible in the Presenter's View.
-->

LAST HINT: When loaded in a text editor you will find this final page close to the
end (or can locate it easily by searching for LAST HINT); if you start from here
instead from the top it may be be easier to discover the document structure, as at
the beginning there are first a number of layout template pages not visible in the
browser.

---
template: plain
name: cpp11_extensions
header: ## C++11 Extensions (and some related Boost)

--------------------------------------------------------------------------------

* [General and `const`-qualified Pointers	](#const_pointers)
* [Classic References (Lvalue References)	](#classic_references)
* [Comparison of Pointers and Reference		](#pointer_vs_reference)
* [Rvalue References (introduces with C++11)	](#rvalue_reference)
* [C++11 Brace Initialisation			](#cpp11_uniform_initialization)
* [Template Basics				](#template_basics)
* [Perfect Forwarding				](#perfect_forwarding)
* [Range (-based) `for`-Loops			](#range_based_for)

--------------------------------------------------------------------------------

---
template: plain
name: const_pointers
header: ### General and `const`-qualified Pointers

```
int *p1;       // pointer and pointed-to memory are modifiable
p1 = …;        // OK
*p1 = …;       // OK (assuming p1 points to valid memory now)
```
For a pointer `const` my refer to **the pointer itself** …
```
int *const p3 = …; // must be initialized (with address of an int)
p3 = …;            // ERROR (would modify pointer itself)
*p3 = …;           // OK (modifies pointed-to memory location)
++*p3;             // OK (increments pointed-to memory location)
++p3;              // ERROR (would increment pointer itself!) 
```
… or the memory location **reachable via the pointer**:._[]
```
const int *p2; // same as: int const *p2;
p2 = …;        // pointer is still modifiable, but ...
*p2 = …;       // ... ERROR at compile-time!
```

.F[:
Of course, both kinds of `const`-qualification may be combined if it makes sense
for a given purpose, e.g. `const int *const p4 = …;` (or – switching positions
of the qualification and the type to which it is applied:
`int const *const p4 = …;`).
]

---
template: plain
name: classic_references
header: ### Classic References (Lvalue References)

The classic example is a function swapping the contents of two variables:

.pull-left[
```
void swap(int *p, int *q) {
    const int t = *p;
    *p = *q;
    *q = t;
}
…
int a, b;
…
if (a > b) swap(&a, &b);
…
```
]

.pull-right[
```
void swap(int &r, int &s) {
    const int t = r;
    r = s;
    s = t;
}
…
int a, b;
…
if (a > b) swap(a, b);
…
```
]

On the left pointers are used and addresses are handed over explicitly, on the
right arguments are defined as references, causing implicit dereferencing inside
`swap` and handing over addresses at the call site..[]

.F[:
So the difference is mostly notational (simplified source code with references),
while generated machine instructions are typically the same, though there is no
strict rule enforcing this. E.g. depending on compile time debug options
different safety checks could be generated for pointers and references.
]

---
template: plain
name: reference_initialisation
header: #### Initialising References

By concept references always denote existing memory locations,._[] therefore
they need to be initialised.

.N[
After its definition and initialisation a reference cannot be modified so that
it subsequently refers to a different memory location.
]

From that point of view references are like constant pointers, which may **not**
be modified themselves, though referenced memory can be read **and** written.

```
int v1, v2;  // some variables ...
int &r = v1; // reference is initialized
```

The following is **not** a compile error, but it also does **not** cause `r`
to reference `v2`:
```
r = v2;  // copies current content of v2 to v1 (referenced by r)
```

.F[:
Not considering some artistic ways of initialisation to deliberately subvert
this property of a reference (like `T &r = *reinterpret_cast<T*>(0);`), an
invalid reference might be created by accident when a dereferenced pointer is
used to initialise a reference without prior checking: `T *p = 0; … T &r = *p`;
]

---
template: plain
name: const_reference
header: #### Constant References

A `const` qualifier for a reference always effects memory access via the
reference.

.N[
References which are `const`-qualified only allow reading memory, even if the
referenced memory (or variable) is writable.
]

In the following example the variable `v` may be modified directly and via `r1`,
but is read-only when accessed via `r2`:._[]

```
T v;
T &r1 = v;       // r1 now refers to content of v
const T &r2 = v; // r2 also refers to content of v
…
r1 = …; // OK (actually changes v)
r2 = …; // ERROR (at compile time)
```

.F[:
It should be obvious that in the light of references a value-tracking compiler
must be careful not to optimise-out *read* memory access with no intervening
*write*: the content of some location might still have been modified through a
different access path.
]

---
template: plain
name: const_correctness
header: #### Achieving the Const-Correctness

The C++ compiler catches constructs that may subvert const-correctness.

.pull-left[

```
const T cv = …;
const T &cr = cv; // OK
T &r = cv;        // ERROR
```
]

.pull-right[

```
const T cv = …;
const T *cp = &cv; // OK
T *p = &cv;        // ERROR
```
]

Aside from the notational there is **no substantial difference** between
pointers and references in the two examples above.._[]

.W[
If the above initialisation would compile, the non-modifiable variable `cv`
might be modified via a non-`const` reference (`r`) or a pointer to non-`const`
memory (`p`).
]

.F[:
GCC usually emits the same machine code for references and pointers, as long as
both are used correctly and semantically equivalent. (To try some examples
easily you may want to go to the following site: http://gcc.godbolt.org)
]

---
template: plain
name: const_ref_args
header: #### Reference Arguments

As reference initialisation occurs when handing arguments to functions, all the
peculiarities and special cases discussed so far will be mostly likely observed
there.

A typical lapse is to forget to add `const` to read-only reference arguments:
```
void foo(double &arg) {
    …
    … // all access to arg is non-modifying
    …
}
```

.pull-left[
Not callable with literal constant or `const`-qualified variable:
```
foo(0.0); // ERROR
double const PI = 3.14;
foo(PI);  // ERROR
```
]

.pull-right[
No temporaries are silently created:._[]
```
int x = 42;
foo(x);    // ERROR
foo(2*PI); // ERROR
```
]

.F[:
The reason is to avoid surprising effects that would occur especially if a
temporary were created for type coercion, and modifications were then applied to
the temporary only but not to the variable actually used as argument (though it
was "obviously" handed over by reference). 
]

---
template: plain
name: pointer_vs_reference
header: ### Comparing Pointers to References

References may be viewed in two ways:

* **Either** an alternative syntax for pointers, which

  * during initialisation expects an lvalue of which the address is taken
    (i.e. "`&`" is automatically and invisibly applied);

  * on each **use** implies the dereferencing operation on each use
    (i.e. "`*`" is automatically and invisibly applied).

* **Or** an alias name for an existing memory location with a matching type.

.N[
Taking inot account the invisibly applied operations to references, then there
are usually the same machine instructions generated for references as are for
pointers – the difference is in the syntax for initialisation and access.._[]
]

.F[:
Hint: When compiling with `g++` or `clang++` you may want to use the command
line option "`-S`" (upper case) and have look at the assembler code stored in a
file with suffix "`.s`" (lower case).
]

---
template: plain
name: rvalue_reference
header: ### Rvalue Referenes

[Rvalue References]: http://en.cppreference.com/w/cpp/language/reference

[Copy Constructor and Assignment]: #copy_ctor_assign
[Move Constructor and Assignment]: #move_ctor_assign

C++11 introduced [Rvalue References]. They may only be initialised by
expressions, i.e. memory locations introduced to hold temporaries with no other
access path.

Following are the most important rules:
```
T &r = …;          // … must be modifiable T in memory
const T &cr = …;   // … must be modifiable T in memory OR
                   //        non-modifiable T in memory OR
                   //        temporary T in memory (expression)
T &&rr = …;        // … must be temporary T in memory (expression)
```

.N[
The main use for rvalue references are to overload functions differently for
arguments denoting **either** existing **or** temporary objects, and again the
main use for this is to implement [Copy Constructor and Assignment] differently
from [Move Constructor and Assignment].
]

.F[:
As a function argument an rvalue reference is in most any case **not**
`const`-qualified, as the temporary reachable over it needs to be modified
(within the limits that the destructor needs still to work correctly). 
In contrary a classical reference typically **will** be `const` qualified if
introduced for improved performance of read-only accesses.
]

---
template: plain
name: cpp11_move_semantics
header: ### C++11: Move Semantics

[RVO and NRVO]: http://stupefydeveloper.blogspot.de/2008/10/c-rvo-and-nrvo.html
[Perfect Forwarding]: http://thbecker.net/articles/rvalue_references/section_07.html

Move semantics provide the solution to two problems that could not (always)
be avoided in C++98:

* Efficient use of *value types as function return values*, e.g. if they
  represent large containers.

* Implementing types that are *movable* but not *copyable*.._[]

.F[:
With C++98 there is no real solution to the problem to differentiate between
moveable and copyable types. Even if `operator=` stays undefined and overloaded
global functions `assign` and `move` were used consequently, especially in
type-generic code of template implementations something in the vein of
[Perfect Forwarding] could not be achieved, at least not with as little code
as can now.
]

.I[
Even before C++11 in many practical cases the leeway given to a compiler to
apply [RVO and NRVO] could achieve much to **return large data structures by
value efficiently**.
]

But as there is no guarantee in this respect, the usual recommendation for C++98
was to hand-out large containers via reference arguments, not by return value –
and this recommendation should possibly be followed even in C++11.

---
template: plain
name: rvalue_reference_overloading
header: ### Overloading for Rvalue References

Move semantics heavily build on Rvalue References defined with a double
ampersand:
```
void foo(const T &classic_reference) { … } //first
void foo(T &&rvalue_reference) { … } //second
```

With the above two overloads C++11 would bind

* the first `foo` to arguments that are plain variables (including `const`
  qualified variables),

* the second `foo` to arguments that are temporaries which will be destroyed
  soon after use.._[]

```
T a; const T b; extern T bar();
foo(a);	    // calls first
foo(b);	    // calls first
foo(bar()); // calls second
foo(a+a);   // calls second -- provided T supports operator+
```

.F[:
Such as function calls, but also including constants and expressions (with some
reasonable exemptions).
]

---
template: plain
header: ## Copyable and Movable Types

Instances of the following class will be both, copyable and movable:
```
class MyClass {
    …
public:
    MyClass(const MyClass &); // classic copy constructor and ...
    const MyClass& operator=(const MyClass &); // copy assignment
    …
    MyClass(MyClass &&);        // C++11 move constructor and ...
    const MyClass& operator=(MyClass &&);      // move assignment
}
```

By supplying both of move and copy support, or only the one or the other, or
none at all, instances of `MyClass` can easily be made

* **Copyable** and **Movable**,
* **Copyable** but not Moveable,
* not Copyable but **Movable**, or
* neither Copyable nor Moveable.

---
template: plain
name: cpp11_defaulted_deleted
header: ### C++11: `default`-ed and `delete`-d Operations

C++11 furthermore provides a particular syntax to request or forbid compiler
generated constructors and assignments, making it easy to write a class that
supports the required behavior:
```
class MyClass {
    …
public:
    MyClass(const MyClass &)                   = delete;
    const MyClass& operator=(const MyClass &)  = delete;
    …
    MyClass(      MyClass &&)                  = default;
    const MyClass& operator=(      MyClass &&) = default;
 };
```

.N[
It is probably easy to spot that instances of the above class will be moveable
but not copyable and what needs to be changed if that should be different.
]

In case the default implementation provided for the above operations is not
appropriate, then of course a specific implementation can be supplied.

---
template: plain
name: boost_noncopyable
header: ## Boost: Noncopyable

[`boost::noncopyable`]: http://www.boost.org/doc/libs/release/libs/utility/utility.htm#Class_noncopyable

As C++ always generates a copy constructor when none is specified,._[] the usual
technique is to *declare-but-not-implement* the unwanted operation.

.F[:
Note that with C++11 the rules changed in so far as **no default copy-constructor
will be provided if a move-constructor is provided**, and the same holds for copy-
and move-assignment. The reasoning behind that rule is that as soon as a specific
behavior is necessary for one, copy or move, it will probably also be the case for
the other.
]

Via deriving from `boost::noncopyable` the intent can be made more obvious
(and code a bit more compact):
```
class MyClass : boost::noncopyable {
    …
    … // whatever (but no need any more to define
    … // operations that never get implemented)
    …
};
```

---
template: plain
name: cpp11_uniform_initialization
header: ### C++11: Uniform Initialization

C++ traditionally had many forms of initialization, some of which were limited
to certain contexts:
```
int x = 0;                     // traditional style
const std::string greet("hi"); // constructor style
struct s {
    int a;
    char z;
} v = { 42, '!' };             // aggregate initialization
std::string empty();           // INVALID (as initialization)
unsigned u = unsigned();       // not common but valid (in C++)
```

Since C++11 curly braces may be used in any initialization context:._[]
```
int x{0};                      // explicit zero initialization
const std::string greet{"hi"}; // initialization by constructor
string empty{};                // valid for default constructor
unsigned u{};                  // implicit zero initialization
```

.F[:
Compared to classic initialization some rules have slightly changed:
E.g. if the value of the initializing expression cannot be represented in
the initialized variable, this is a compile time error.
]

---
template: plain
name: cpp11_initializer_lists
header: #### C++11: Initializer Lists

Initializer lists are sequences of comma-separated values enclosed in curly
braces.

* They are valid wherever a function accepts an argument of type
  `std::initializer_list`.

* This includes many constructors for standard containers:._[]

.W[
A few usage forms introduced ambiguities for which C++11 defined disambiguating
rules – sometimes little intuitive ones.
]
```
vector<short> primes({ 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 });
const map<string, string> words = {
    { "zero", "null" }, { "one", "eins" }, { "two", "zwei" },
    …
};
vector<int> x{3};  // A vector initialized with a "list" just
                   // holding a single 3?
                   // Or rather a vector sized to 3 elements
                   // that shall be default-initialized?
```

---
template: plain
name: boost_value_initialized
header: #### Boost: Value Initialized

[Boost.Value_initialized]: http://www.boost.org/doc/libs/release/libs/utility/value_init.htm

Using the correct initialization syntax can pose a problem._[] at times:
```
template<typename T> void foo() {
    T local = … // ???
    …
}
```

* A plain `T local;` would default initialize classes but leaves basic types
  uninitialized.

* Classic style `T local = 0`; would only zero-initialize basic types.._[]

[Boost.Value_initialized] provides a utility template, causing either zero or
default initialization, depending on the type of `T`:
```
value_initialized<T> local; // uniform use of the Boost solution
T local = T();       // a (somewhat lesser known) C++98 solution
T local{};           // C++11 uniform initialization as solution
```

.F[:
Actually the state of affairs is a bit more complicated: The above would also
work if `T` were a class with a (non-`explicit`) constructor taking an argument
type to which `0` can be converted. Besides all arithmetic types this include
`bool` (`0` converted to `false`) and any pointer type (`0` converted to
`nullptr`).
]

---
template: plain
name: boost_container_initialization
header: #### Boost: Container Initialization

[Boost.Assign]: http://www.boost.org/doc/libs/release/libs/assign/doc/index.html

[Boost.Assign] provides some operator overloading to allow a more readable
initialization syntax for sequential and associative containers.

Overloaded `operator,` and `operator+=` help with sequential containers:
```
vector<int> primes;
primes += 2, 3, 5, 7, 11, 13, 17, 19, 23, 29;
```

For associative containers there is a somewhat tricky overload of `operator()`
(function call):
```
map<string, string> words;
words(("one")("eins"))
     (("two")("zwei"))
     …
     (("nine")("neun"))
     ;
```

.N[
Compared to [C++11 initializer lists](#cpp11_initializer_lists) the above not
only looks clumsy but also has the draw-back that no `const`-qualifiers are
possible.
]

---
template: linkinfo
graphic: ParametrizedTypesAndSizes
name: template_basics
header: ### Template Basics

-------------------------------------------------------------------------------

* [Parametrized Types and …			](#parametrized_types)

* [… Compile-Time Constants …			](#parametrized_constants)

* [… Demonstrated with a `RingBuffer` Example	](#example_ringbuffer)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: ParametrizedTypesAndSizes
section: Parametrizing Type
name: parametrized_types
header: #### Parametrized Types

C++-Templates were designed with the original intent to reduce mostly identical
**source code** when different variants of a class or (member) function only
differ in data types.

* The function or class will take a formal type parameter list in angle
  brackets,

* introducing **symbolic names** to the compiler that represent types which
  will later be specified concretely.

.N[
The symbolic type names may be used anywhere in declarations and in the
implementation of the class, where a type is syntactically permitted.
]

When instantiating a **class template** concrete types need to be named at the
corresponding position in the angle brackets while for a **function template**
such types are often visible (and deduced) from the types of arguments given by
the caller.

.F[:
Each name is preceded by the keyword `class` or `typename`, which may be used
interchangeably with the same meaning. (But note that the two keywords have
different meanings elsewhere.)
]

---
template: withinfo
graphic: ParametrizedTypesAndSizes
section: Parametrizing Size
name: parametrized_constants
header: #### Parametrized Compile-Time Constants

Besides types a template class or functions may also parametrize compile-time
constants.

For that purpose

* the function or class will take a formal value parameter list in angle
  brackets,

* introducing **types and symbolic names** to the compiler that represent
  constants of their given type.

.N[
The symbolic names may be used anywhere in the class implementation (usually
following) where syntactically a constant of the given type is permitted.
]

When instantiating a (class or function) template concrete constants need to be
named at the corresponding positions in the angle brackets.._[]

.F[
The usual automatic type converions take place as necessary – e.g. between
arithmetic types.
]
  
---
template: withinfo
graphic: ParametrizedTypesAndSizes
section: Parametrizing Type and Size
name: example_ringbuffer
header: #### Example `RingBuffer`

Turning `RingBuffer`-class originally implemented with given (fixed) type and
size into a template is straight forward as it boils down to some rather
systematic "find and replace":

* This is especially true as `double` occurs in the source only where the (now)
  parametrized type symbol `T` needs to appear.

* The constant `11` specifies (in the original code) the maximum number of
  elements in the `RingBuffer` **plus one!**._[]

  * From the perspective of the `RingBuffer`-s user it makes more sense to
    supply the net size `N` (number of elements that can actually be held).

  * This can be easily achieved by replacing each occurence of `11` (in the
    original code) with `(N+1)` (in the template).

.F[:
So that the *empty* and *full* state can be easily discerned without an
additional flag, the buffer never gets completely filled but a single element is
always left unused, if the position into which to "put" is directly behind the
position from which to "get".
]

---
template: plain
name: perfect_forwarding
header: ## Perfect Forwarding

A special use case for templates is *Perfect Forwarding*, which basically is
about keeping the "Rvalue-ness" of a function argument until it is used.

It can be applied

* either in [cookbook style](#perfect_forwarding_cookbook) or

* with first explaining (and consequently trying to grasp) a lot of its
  [background](http://thbecker.net/articles/rvalue_references/section_01.html).

.N[
One key point with both approaches is to understand that the rvalue reference
declarator (`&&`) is special if used with a template argument.
]

Scott Meyers has even coined a special term for it: [Universal References]

[Universal References]: http://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers

---
template: plain
name: perfect_forwarding_cookbook
header: ### Perfect Forwarding - Cookbook Style

Perfect forwarding is achieved by applying the following recipe:._[]
```
template<typename T1, typename T2>
void foo(T1 &&arg1, T2 &&arg2) {
    bar(std::forward<T1>(arg1));
    baz(std::forward<T2>(arg2));
};
```

.N[
If there are overloads of `bar` and `baz` optimized for lvalue and rvalue
arguments, the appropriate one will be called.
]

.F[:
Perfect forwarding always requires the use of templates, even if it is applied
to cope with the exponential explosion of overloads necessary if only arguments
of known types are to be forwarded, like here:
```
  // Assume objects of these classes can be arguments to foo, which it
class MyClass { … }; // it forwards to bar and baz and the caller may
class AnOther { … }; // either supply lvalues or rvalues as argument:
…
void foo(const MyClass  &arg1, const Another  &arg2) { … }
void foo(const MyClass  &arg1,       Another &&arg2) { … }
void foo(      MyClass &&arg1, const Another  &arg2) { … }
void foo(      MyClass &&arg1,       Another &&arg2) { … }
```
]

---
template: plain
name: perfect_forwarding_background
header: ### Perfect Forwarding - The Background

The background of perfect forwarding combines three essential pieces:

1. For a template argument `T&&` there is a special deduction of `T`:
   * `T` is *reference* for lvalue arguments,
   * otherwise it is the plain argument type  
     (as usual with `&` and `const` stripped away).

2. Reference collapsing defines what happens if two reference declarators
   are applied in a row:
   * `&` and `&` → `&`
   * `&` and `&&` → `&`
   * `&&` and `&` → `&`
   * `&&` and `&&` → `&&`

3. `std::forward<T>(expr)` statically casts `expr` to `T&&`.

.I[
For more information on `std::forward` see:
http://en.cppreference.com/w/cpp/utility/forward
]

---
template: plain
name: range_based_for
header: ## Range (-based) `for`-Loops

C++11 introduced a unified syntax to loop over all elements of a collection.

It looks similar to the classic `for`-Syntax, but  inside the parentheses
following the keyword `for`

* a place-holder variable

* is separated by a colon (`:`)

* from a collection.

Its use becomes usually obvious from some characteristic examples, like those
shown in the next pages, and also feels quite natural soon.

.I[
For more information on range-based loops (aka. "range-for") see:
http://en.cppreference.com/w/cpp/language/range-for
]

---
template: plain
header: ### Example: Range-For over Classic Array

Using range-`for` to read or modifying all elements in a classic array …
.pull-left[
```
int data[100];
… // fill with 100 values
```
]
.pull-right[
```
for (int e : data)
    … // sequentially read
      // values from data via e
…
for (int &v : data)
    … // sequentially modify
      // values from data via v
```
]
.pull-left[
… the code on the right side is equivalent to the code below, accessing all
elements of data one after the other by index …
```
for (int i = 0; i < 100; ++i) {
    int e = data[i];
    … // read data[i] via e
}
…
for (int i = 0; i < 100; ++i) {
    int &v = data[i];
    … // modify data[i] via v
}
```
]
.pull-right[
… or – more C-style – via pointer:._[]
```
for (int *p = data;
    p < data+100; ++p)
    … // read data via *p
…
for (int *p = data;
    p < data+100; ++p)
    … // modify data via *p
```
]

.F[:
Performance evaluations typically show neither version has an advantage over the
other.
]

---
template: plain
header: ### Example: Range-For over STL-Vector

One of the main advantages of range-`for` is its uniform syntax that applies to
STL containers too (below left) instead of classic iterator loop (right):
.pull-left[
```
std::vector<int> data;
… // fill with values
for (int e : data)
    … // read data values
      // via e
…
for (int &v : data)
    … // modify data values
      // via v
```

```
for (auto e : data)
   … // access via copy
for (const auto &e : data)
   … // access via reference
```
]
.pull-right[
```
typedef
vector<int>::iterator Iter;
for (Iter it = data.begin();
          it != data.end();
        ++it)
    … // access (read or
      // modify) data
      // values via *it
```
Also `auto` comes in handy as well for read-only (left) as for modifying
access (below):._[]

```
for (auto &e : data)
   … // access via reference
```
]

.F[:
Actually this will allow for modifying access only if `data` is not
`const`-qualified, because otherwise the place-holder of the range-`for`
loop would be deduced as `const` reference!
]

---
template: plain
header: ### Example: Range-For over STL-Map

In case of an STL-Map the place-holder is in the range-`for` loop is a pair of
the maps key value-type … which might seem inconvenient to specifiy …
```
std::map<std::string, int> data:
… // fill with key-value pairs
for (std::pair<std::string, int> e : data)
    … // access key via e.first and
      // associated data via e.second
```
.pull-left[
… but again `auto` comes in handy:
```
for (const auto &e : data)
    … // access key via e.first
      // and associated data
      // read-only via e.second
```
]
.pull-right[
```
for (auto &e : data)
    … // access key via e.first
      // and associated data
      // modifiable via e.second
```
Note that the key is always non-modifiable!
]

---
template: plain
header: ### Example: Range-For over Non-Standard Containers

It is well possible to use range-`for` loops with non-standard containers
```
MyContainer data;
… // fill data with values
for (auto e : data) … // read (by copy) via e
for (const auto &e : data) … // read (efficiently) via e
for (auto &e : data) … // access modifiable via e
```

given one of the following helpers exist:._[]
.pull-left[
**Either** `MyContainer` provides (the standard STL container interface with) the
**member functions**:

* `… MyContainer::begin() …`
* `… MyContainer::end() …`.

]
.pull-right[
**Or** there are overloads with an argument of type `MyContainer` for the
**global functions**:

* `… begin(… MyContainer& …) …`
* `… end(… MyContainer& …) …`.

]

.F[:
In both cases the return type and some details of the argument transfer in case
of global functions are left unspecified here. But what is returned from these
functions must be equality-comparable (and eventually compare unequal if the
loop is expected terminate regularly) and there must be increment and
dereference operations for the returned type.
]

---
template: plain
name: range_for_init_list
header: ### Example: Range-For with Initialiser List

It is also possible to combine range-`for` with `std::initializer_list`-s:
```
enum class Color { Red, Blue, Green, Unspecified = -1 };
…
for (auto c : { Color::Red, Color::Blue, Color::Green }) {
    … // do something with c
}
```

If such lists (of all values of some enumeration type) are required in many
places, they may be specified as initialised constants, preferably close to the
definition of the enumeration, so that both can be easily maintained in
parallel.
```
enum class Color { Red, Blue, Green, Unspecified = -1 };
constexpr auto ALL_COLORS = {
    Color::Red, Color::Blue, Color::Green
};
…
for (auto c : ALL_COLORS ) …
```

---
template: plain
header: ### Usage Recommendations for Range-`for` Loops

.N[

* Replacing typical iterator loops over containers with range-`for` usually
  causes no problems and will result in code that is more readable and easier to
  maintain.

* The same is often true for `std::for_each`, at least as long as a container is
  processed **completely**.

* For processing container sub-ranges `std::for_each` is still useful.

* Non-standard containers should **strongly consider** to provide the interface
  required by range-`for` to iterate over their content.

]
.W[
Efficiency problems may result if some container holds large objects which are
not cheap to copy and the place-holder in a range-`for` loop is not specified as
reference.._[]
]

.F[:
The recommendation for *generic code* is to use `auto&&` because this will
always give optimal results. On the other hand, `auto&&` is a language construct
which should not be carelessly (i.e. without really understanding the
implications).
]

---
template: plain
name: callables_cpp11_boost
header: ### Callables, `function`, and Lambdas

[Type Erasure]: https://akrzemi1.wordpress.com/2013/11/18/type-erasure-part-i/

This section covers *Callables*, which in classic C++ (until C++11) subsumes

* classic C-style function pointers and
* C++-style [Functors](#function_objects).._[]

As all of these are different types C++11 recognized the need for [Type Erasure]
and introduced

* [`std::function`](#cpp11_std_function),
* originally developed as [Boost.Function](#boost_function).

Furthermore [C++11 Lambdas](#cpp11_lambdas) now provide a shorthand to define
functions at the point of use.

There has also been a "pure-library solution" provided by
[Boost.Lambda](#boost_lambdas) which may be a bit briefer in simple cases but
will most probably be superseded now by the C++11 solution.

.F[:
Functors are classes that overload `operator()` what – to plain functions –
mainly adds the option for further parametrisation (in addition to the
caller-supplied arguments).
]

---
template: plain
name: cpp11_std_function
header: #### Using `std::function` vs. Fully Generic Types (1)

A predicate in a (templated) algorithm could be restricted to a callable type
via `std::function`:
```
template<typename T1, typename T2>
T2 filter(T1 beg, T1 end, T2 to,
          std::function<bool(typename T1::value_type)> pred) {
    while (beg != end) {
        const auto &val = *beg;
        if (pred(val))
            *to++ = val;
        ++beg;
    }
    return to;
}
```

If `T1` and `T2` denote types (maybe different to each other)

* which do not vary for many calls
* that all use a different predicate

there will be **only one single** instantiation of this function. (I.e. the
instantiation will not depend on the actual predicate.)

---
template: plain
name: function_vs_generic
header: #### Using `std::function` vs. Fully Generic Types (2)

In contrast to the previous example, with the following template the compiler is
able._[] to inline the predicate evaluation, resulting in some "code bloat":
```
template<typename T1, typename T2, typename T3>
T2 filter(T1 beg, T1 end, T2 to, T3 pred) {
    while (beg != end) {
        const auto &val = *beg;
        if (pred(val))
            *to++ = val;
        ++beg;
    }
    return end;
}
```

.I[
No general rule or guideline can be given which solution to prefer over the
other, as this depends on various factors.
]

.F[:
Whether the actual predicate evaluation will be inlined also depends on other
factors, like its definition is visible (and maybe explicitly made `inline`),
or whether it is a classic function for which at the call site only an `extern`
declaration is known. Also note that different compilers may vary in handling
the above and the final result may depend on the optimization level requested.
]

---
template: plain
name: boost_function
header: #### Boost: Callables

[Boost.Function]: http://www.boost.org/doc/libs/release/doc/html/function.html

C++11 `std::function` emerged from [Boost.Function].

There are few differences, the most important is that `boost::function` tried
to be compatible with older compilers that did not fully support the required
*Preferred Syntax*.

So Boost supplied its *Portable Syntax* as an alternative:
```
boost::function0<void> f1;     // no args, returning nothing
boost::function1<int, int> f2;     // int arg, returning int
boost::function1<double, const char *> f3;
boost::function3<double, const char *, const char**, int> f4;
```

* It encodes the return type as first template argument,

* followed by the argument types (if any), and

* reflects the **number of arguments** in the class name.

---
template: plain
name: cpp11_lambdas
header: #### C++11: Lambdas

[Lambdas]: http://en.wikipedia.org/wiki/Anonymous_function

Introducing [Lambdas] with C++11 was a major step to bring C++ at level with
many other modern programming languages, in which

* functions not only were made *"First Class Citizens"* but

* it is also possible to specify a function body **at its point of use**,._[]
  especially as argument to some other function call.

.F[:
This is why lambdas are also known as *Function Literals*.
]

.N[
The general definition syntax

* starts with a capture list in square brackets,

* followed by an argument list in round parenthesis,

* followed by the function body in curly braces.
]

---
template: plain
name: lambda_definition_syntax
header: #### Lambda 101 – Definition Syntax Example

Building on the `filter` algorithm from a prior slide the predicate could be
supplied directly and clearly visible at the call site:
```
std::vector<double> data, result;
… // fill data
filter(data.begin(), data.end(), std::back_inserter(result),
       [](double e) { return (e < std::sqrt(2.0)); }
};
```

.F[:
An algorithm like this is available as `std::copy_if` in C++11. (It was
actually missing from C++98 where `std::remove_copy_if` had to be used with
the predicate logic inverted.)
]

.N[
Note that the above will work with either version of filter, the one with the
[predicate parametrized to any type](#function_vs_generic) and the one with the
[predicate limited to an appropriate callable](#cpp11_std_function).
]

---
template: plain
name: lambda_capture_list
header: #### Lambda 101 – Capture Lists (Motivation)

It should be understood that for any function (e.g. `filter`) expecting some
other function as argument,

* the function handed over by the caller (i.e. as argument to `filter`)
* must be callable by the coded inside (i.e. the implementation of `filter`).

Therefore it is not possible to hand over additional arguments directly:
```
filter(data.begin(), data.end(), std::back_inserter(result),
       [](double e, double max) { return (e < max); }
};
```

.W[
This will not compile because the lambda not matches the expectation
`filter` has about the use of its fourth argument.._[]
]

.F[:
How the error manifests in a compiler diagnostic is a different issue: if –
after some type deduction – `filter` had an argument of type
`std::function<bool(double)>` the compiler will complain at the call-site
not being able to initialize the predicate argument from what is specified;
for a fully generic template it will rather complain inside the code of the
template where the actual call is coded.
]

---
template: plain
name: lambda_capture_list_example
header: #### Lambda 101 – Capture Lists (Example)

In a capture list variables from the local context may be named.

Then in the code generated for the lambda that argument is transfered via a
special path:._[]
```
double max;
std::cin >> max;
…
filter(data.begin(), data.end(), std::back_inserter(result),
       [max](double e) { return (e < max); }
};
```

.F[:
If you are curious about that you will get an idea when [Classic C++ Function
Objects](#function_objects) are covered.
]

So far this presentation only tried to give some first clues about the purpose
and basic use of lambda capture lists.

.N[
There are many more details which have not been covered yet, like handing
over references in the capture list or some shortcuts for it.
]

Please lookup more information in the relevant reference documentation.

---
template: plain
name: lambda_capture_list_pitfalls
header: #### Lambda 101 – Beware of the Pitfalls

For efficiency reasons C++11 does **not demand any special rules for stack
unwinding** when a lambda captures a local context by reference:._[]
```
function<void()> foo(int n) {
    return [&n]() { std::cout << n; }
}
…
foo(42)();
```

.F[:
It is basically a similar situation as returning the address of a local variable
from a function, which is undefined behavior since the first days of C. But
while most any decent compiler will warn about this, the problem shown here most
often goes unnoticed. It can be expected that code like above will trigger a
warning too when future C++ compilers improve their checks in this respect.
]

.W[
Therefore the above code fragment steps into the area of undefined behavior.
]

* Of course, the situation might go unnoticed for a long time as the correct
  value just happens to be in the expected memory location …

* **… until, some day, a completely unrelated change is made!**

---
template: plain
name: function_objects
header: #### Classic C++ Function Objects

[Functors]: http://www.cprogramming.com/tutorial/functors-function-objects-in-c++.html

Prior to C++11 lambdas – in C++98 and C++03 – code that can now be written
elegantly with lambdas had to be written with [Functors]:._[]
```
struct LessCompare {
    const double limit;
    LessCompare(double lim) : limit(lim) {}
    bool operator()(double e) { return (e < limit); }
};
…
double max;
std::cin >> max; // only as example (max not known at compile-time)
…
filter(data.begin(), data.end(), std::back_inserter(result),
       LessCompare(max)
);
```

.F[:
To avoid unnecessary complexity the `LessCompare` functor was not written as
a template here. Of course this could have been easily done (and in practice
probably would have done) to make the functor applicable to any type supporting
`operator<()`.
]

---
template: plain
name: boost_lambdas
header: #### Boost: Lambdas

As lambdas were missing for a long time from the C++ language proper, it was
tried to emulate them via the library.

To rewrite the example that has been used a number of times:

```
#include <boost/lambda/lambda.hpp>
…
filter(data.begin(), data.end(), std::back_inserter(result),
       boost::lambda::_1 < max);
```

* The innocuous looking `boost::lambda::_1` above, together with a clever
  overload of `operator<`, triggers the complex template based machinery.._[]

* Last and finally a functor is created that overloads `operator()` to be
  callable with a single argument, returning `true` if the argument is less
  than `max`.

.F[:
If you are curious to learn the details try to get familiar with
[Expression Templates] first, because these build the underlying general
mechanism.
]

  [Expression Templates]: http://en.wikipedia.org/wiki/Expression_templates
---
template: plain
name: boost_lambda_details
header: #### Boost: Lambda Details

While C++11 lambdas now provide a much more general and flexible solution, it
can be argued that Boost lambdas are less blatant and in many cases of
practical relevance can be create with much fewer key strokes.._[]

.F[:
Whether or not this is considered to be an issue to guide a decision pro or
contra Boost lambdas may also depend on the capabilities of an IDE, which –
if properly configured – might insert source code templates for frequently used
C++11 lambdas with a keyboard shortcuts.
]

.N[
This is especially true if the namespace `boost::lambda` is opened via `using`
 directives, because then the occurrence of the plain identifiers `_1`, `_2`, or
`_3` in an expression are sufficient to trigger the mechanism.
]

```
std::vector<double> data;
…
sort(data.begin(), data.end(), (_2 < _1)); // sort data in reverse
```

The above example, rewritten for C++11 lambdas, illustrates the point:
```
sort(data.begin(), data.end(), [](double lhs, double rhs) {
                                   return (rhs < lhs);
                               }); // sort data in reverse
```

---
template: plain
name: boost_lambda_trivial
header: #### Boost: Lambda Beyond Trivial Use

Beyond the trivial use in pure expressions – and even there sometimes – using
Boost Lambdas (or rather the expression templates behind them) can quickly
get intricate.

While it is well possible to translate the following into a Boost Lambda, you
probably will not want to do it when you can avoid it:._[]
```
vector<double> data;
…
int line{0};
std::for_each(data.begin(), data.end(),
              [&line](double e) {
                  std::cout << ++line << ':' << e << '\n';
                  if (line % 10 != 0) std::cout << "---\n";
              });
```

.F[:
Of course, if you really have to back-port the above code written for C++11 to
some older compiler it may be good to know that Boost Lambdas stretch far beyond
the simple, expression-like use cases and all the typical flow control directives
are supported.
]

---
template: plain
name: cpp11_vs_boost_lambda
header: #### C++11 vs. Boost Lambdas

Which one to prefer cannot be generally decided:

* For very simple expressions Boost Lambdas may be considered as an alternative.

* On the other hand, as soon as the situation is a bit more involved, correct
  use of Boost Lambdas quickly becomes tricky (at least).

Generally speaking with Boost Lambdas there is a steep learning curve beyond the
trivial cases, especially when more flow control is necessary as a single
expressions can provide.

.N[
It will not make much sense to rewrite all usages of Boost Lambdas now that
C++11 lambdas are available, but rewriting the complicated ones to better
comprehensible C++11 lambdas may be worth a consideration.._[]
]

---
template: plain
name: cpp11_and_boost_exceptions
header: ## Exceptions

--------------------------------------------------------------------------------

* [Exception Basics				](#exception_basics)
* [Exception Guidelines				](#exception_guidelines)
* [C++11 `noexcept`				](#cpp11_noexcept)
* [Boost.Exception				](#boost_exception)

--------------------------------------------------------------------------------

---
template: linkinfo
graphic: ExceptionBasics
name: exception_basics
header: ### Exception Basics

-------------------------------------------------------------------------------

* [Hierarchical Exception Classes		](#exception_hierarchies)

-------------------------------------------------------------------------------

* [Flow of Control with and without Exceptions	](#exception_flowcontrol)

-------------------------------------------------------------------------------

* [Understandig Exception Classes as Labels	](#exception_as_label)
* [Grouping Related Exceptions 			](#exception_grouping)
* [Activating Re-Entry Points			](#exception_try_block)

-------------------------------------------------------------------------------

* [Re-Throwing Exceptions			](#exception_rethrow)
* [Catching Any Exception			](#exception_catchall)

---
template: withinfo
graphic: ExceptionBasics
section: Exception Class Hierarchies
name: exception_hierarchies
header: #### Exception Class Hierarchies

[`std::exception`]: http://en.cppreference.com/w/cpp/error/exception
[`std::logic_error`]: http://en.cppreference.com/w/cpp/error/logic_error
[`std::runtime_error`]: http://en.cppreference.com/w/cpp/error/runtime_error

Exceptions thrown by library functions build a class hierarchy:

* The common base is the class [`std::exception`].

* Derived from this are the following two which may also be a good choice to
  extend the hierarchy for specific purposes:

  * [`std::logic_error`]

  * [`std::runtime_error`]

---
template: withinfo
graphic: ExceptionBasics
section: Execution Path taken for Exception
name: exception_flowcontrol
header: #### Flow of Control with and without Exceptions

When no exceptions are thrown, flow of control is as usual:

.N[
If the end of a `try`-block is reached, all subsequent `catch`-blocks are
skipped over.
]

Insofar behaviour is analogous to an `if`-block which skips all subsequent
`else if` and the final `else`, when the condition (of the first `if`) holds
true.

---
template: withinfo
graphic: ExceptionBasics
section: Exception Classes Viewed as Labels
name: exception_as_label
header: #### Understanding Exception Classes as Labels

When a `throw`-statement is executed, all the `catch`-blocks after an active
`try`-block are like labels, i.e.:

.N[
Control flow always **branches back** (removing stack frames) into the direction
of the main function.
]

* A `catch`-block is chosen

  * according to the dynamic nesting of function calls, **and**

  * **top - down** among all `catch`-blocks subsequent to an active `try`-block.

* The selected `catch`-Block is the first one with an exception type compatible
  to the exception thrown.

* If there is no such `catch`-block, the next active `try`-blocks (closer to the
  main function) is considered.

* If none is found down to the main function program execution stops.

---
template: withinfo
graphic: ExceptionBasics
section: Grouping Exceptions
name: exception_grouping
header: #### Grouping Related Exceptions

Compatibility of the exception thrown and the exception named in a `catch`-block
is – with respect to automatic conversions that may be applied – decided in the
same way as for arguments on function calls:

* Especially the LSP is effective, i.e. publicly derived classes are compatible
  with (any of) their base classes.

* Therefore class hierarchies make sense for exceptions too, as related
  exceptions then may (optionally) be caught in a common `catch`-block.

.N[
Even in the parentheses following `catch` make the construct look like a
function argument list, having the control flow branch back to a `catch`-block
is different from a function calls
]

Rather `catch`-blocks are points for re-entry into a still active function.._[]

.F[:
It is rather some kind of special return into the control flow of the (still)
active function with the (once) active `try`-Block. But there are even more
similarities to a function and a parameter specification, not only that the
usual type conversions take place, but also with respect to `const` and value or
reference access to the exception object thrown. Finally, two requirements
imposed syntactically are that there must always be exactly one "argument" and
that a `catch`-block must always be written as block, so even if it contains
exactly one statement the curly braces may not be omitted.
]

---
template: withinfo
graphic: ExceptionBasics
section: Enabling Handler Blocks
name: exception_try_block
header: #### Activating Re-Entry Points

A `try`-Block becomes active as soon as the control flow reaches the first contained
statement.

.N[
Targets for branching-back in case of an exception throw are only `catch`-blocks
following active `try`-blocks.
]

A `try`-Block is not any longer active after it is left by

* `return`._[]
* `break`
* `continue`

or when last contained statement has completed execution.

.N[
The `catch`-blocks following this `try`-block are not any longer considered as
targets for thrown exceptions.
]

.F[:
If a value is returned, evaluation of an expression may be part of the return.
The evaluation itself takes place while technically still in the active
`try`-block. But when the function has returned and its return value is only
used – say in another copy c'tor outside the function that has returned – the
function's `try`-block is not active any more and hence the `catch`-blocks
following it are not any more possible targets.
]

---
template: withinfo
graphic: ExceptionBasics
section: Re-throw Exceptions
name: exception_rethrow
header: #### Re-Throwing Exceptions

It is not unusual that a `catch`-blocks may only partially resolve the problem
indicated by an exception thrown. Then the exception must be re-thrown from that
`catch`-block.
```
    try {
        …
        … // code that may throw SomeException (no matter if
        … // directly, or indirectly from a function called)
        …
    }
    catch (SomeException &ex) {
        …
        … // (assuming partial recovery only)
        …
        throw;
    }
}
```

---
template: withinfo
graphic: ExceptionBasics
section: Catch Any Exception
name: exception_catchall
header: #### Catching Any Exception

It is possible to specify a `catch`-block to match any exception:

* In the parentheses (analogous to variadic functions) three dots need to be
  specified.

* If present, such a block must be the last of all `catch`-blocks following some
  `try`-block.._[]

.F[:
This is not syntactically enforced but as "`...`" catches any exception and the
`catch`-blocks are considered as label-like targets top down, it will otherwise
catch thing for which a specific `catch`-block follows.
]

```
int main() {
    try {
        …
        …
    }
    catch (...) {
        std::cerr << "!! unhandled exception !!\n";
    }
}
```

---
template: linkinfo
graphic: ExceptionDetails
name: exception_guidelines
header: ## Guidelines for Using Exceptions

-------------------------------------------------------------------------------

* [Disconnected Class Hierarchy		](#disconnected_class_hierarchy)

-------------------------------------------------------------------------------

* [Wrong order of `catch`-Blocks	](#wrong_catch_order)

-------------------------------------------------------------------------------

* [Problematic Re-Throwing		](#problematic_rethrow)

-------------------------------------------------------------------------------

* [No Exceptions from Destructors	](#dtor_exception_nogo)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: ExceptionDetails
section: (No) Disconnected Class Hierarchy
name: disconnected_class_hierarchy
header: ### Disconnected Class Hierarchy

For exceptions classes from a disconnected class hierarchy there is **no**
possibility for catching these exceptions in generic code:
```
int main() {
    using namespace std;
    try {
        …
        … // ordinary application
        …
        return EXIT_SUCCESS; // macro in <cstdlib>
    }
    catch (exception &e) {
        cerr << "terminated by standard exception: "
             << e.what() << endl;
    }
    catch (...) {
        cerr << "terminated by unknown exception" << endl;
    }
    return EXIT_FAILURE; // macro in <cstdlib>
}
```

---
template: withinfo
graphic: ExceptionDetails
section: (Bad) Order of Handlers
name: wrong_catch_order
header: ### (Falsche) Behandlungsblock-Abfolge

With a wrong order of `catch`-blocks

* an earlier, **more general** block

* **hides a subsequent** (more specific) block.

---
template: withinfo
graphic: ExceptionDetails
section: Sub-optimal Re-throwing
name: problematic_rethrow
header: ### Problematic Re-Throwing

Rethrowing an exception is sub-optimal if the original thrown object needs to be
copied.

Furthermore, in case of a derived exception object, this will cause slicing.

.N.center[
**In most any case slicing is not what makes sense.**
]

Hence copying should be avoided:

* Exceptions in a `catch`-block should be specified as reference.

* If a `catch`-block recovers from an exception only partial, it should throw
  the received object with `throw;`.

---
template: withinfo
graphic: ExceptionDetails
section: Optimal Re-Throwing
name: correct_rethrow
header: #### Optimal Re-Throwing

If the scheme shown below is applied, the originally received exeption object
will be re-thrown without making any copy (and hence also no slicing):
```
try {
    …
    … // code that may cause an exception
    …
}
catch (SomeException &ex) {
    …
    // only partial recovery
    throw;
}
```
.N[
A `throw`-Statement without argument following may not only be used in a
`catch`-block but also in a function that is directly or indirectly called
from such a block.._[]
]

.F[:
That way common code of several `catch`-blocks may be placed in a helper
function even if this function has a non-trivial flow of control and the
exception caught is not only re-thrown at the end.
]

---
template: plain
header: #### Compiler Optimisations

[RVO]: http://en.wikipedia.org/wiki/Return_value_optimization
[NRVO]: http://stupefydeveloper.blogspot.de/2008/10/c-rvo-and-nrvo.html

When entering a `catch`-block

```
catch (SomeException ex) …
```
and when leaving a `catch`-block
```
    throw ex;
```

would technically require to copy the exception object.

* Within the limits of the semantics specified by the C++ standard there
  are possible optimisations.

* This implies slicing and not executing private copy constructors …

* … but a copy constructor **need not** be actually executed.

.N[
When an exception is thrown, using RVO is a typical optimisation.._[]
]

.F[:
Also [NRVO] might be considered but in practical cases this will be rare
applicable as typically exception objects are constructed in the `throw`-statement with a
constructor call.
]

---
template: withinfo
graphic: ExceptionDetails
section: (No) Throwing from Destructors
name: dtor_exception_nogo
header: ### No Exceptions from Destructors

.W[
Exceptions thrown from destructors **will cause program termination** if the
destructor is run during stack-unwinding as part of an ongoing exception
handling.
]

Therefore, if a destructor needs to use operations that might throw, its body
should be wrapped in a `try`-block, catching all exceptions:._[]
```
class MyClass {
    …
    ~MyClass() {
        try {
            … // whatever needs be done
        }
        catch (...) {
            if (!std::uncaught_exception()) throw;
        }
    }
}; 
```
.F[:
The example shows how the caught exception might be re-thrown if the destructor
is **not** run as part of some exception handling.
]

---
template: plain
name: cpp11_noexcept
header: ### C++98 `throw`-specifications Deprecated

Most guidelines from C++ experts recommend **not to use** `throw`-specifications
as introduced with C++98.

.N.center[
C++11 turned `throw`-specifications into a *deprecated language feature*.._[]
]

.F[:
This means they might be completely removed from the language, though experience
tells that compilers will still support deprecated features, maybe requiring special
command line options for backward compatibility.
]

---
template: plain
header: #### C++11 `noexcept`-specification

The effect is as follows:

* If some function declared `noexcept` will directly or indirectly throw an
  exception the **program will be terminated** – may be after some user defined
  handler code.

* Hence in **callers** of `noexcept` functions the compiler can omit otherwise
  necessary book-keeping for stack-unwinding.._[]

.N[
Currently there is little experience with respect to `noexcept` and how they
relate to code generation and overall program quality, so there are not (yet)
many guidelines when and when not to use `noexcept`.
]

.F[:
Be sure to understand this: In the callers context exceptions from "`noexcept`"
functions may indeed stay unconsidered … but **not** as the possibility of an
exception is completely excluded but **because the callee will never return**
to the caller's context!
]

---
template: plain
name: noexcept
header: #### Conditional Freedom from Exceptions

Besides what was explained on the previous page `noexcept` is also a
compile-time function which especially in templates is useful to
**conditionally** freedom from exceptions.

* That way some function may express that exceptions will only occur if some
  (unknown) called function throws.

* This allows at compile-time to decide if some piece of code bears the risk
  to throw.

* Using techniques from meta-programming this allows library functions to chose
  a different (probably non-throwing, then) implementation to make itself safely
  made `noexcept`.

---
template: plain
name: noexcept_examples
header: #### Examples for `noexcept`

Some easy calculation – exceptions are completely excluded:
```
float fahrenheit_to_centigrade(float temperature) noexcept {
    return 9.0*temperature/5.0 + 32.0;
}
```

Some vital functionality – no chance to revover, better crash completely:
```
extern void may_fail_catastrophically(int = 42) noexcept;
```

An exception from `bar` is only thrown it `T::foo` throws:._[]
```
template<class T>
void bar(const T &arg) noexcept(noexcept(arg.foo())) {
    … // an exception can neither occur here ...
    arg.foo();
    … // ... nor can an exception occur here
}
```

.F[:
The C++11-syntax is that ugly and requires nested `noexcept`-s.
]


---
template: plain
name: boost_exception
header: ### Boost Exception

[Boost.Exception]: http://www.boost.org/doc/libs/release/libs/exception/doc/boost-exception.html
[Motivation]:      http://www.boost.org/doc/libs/release/libs/exception/doc/motivation.html

[Boost.Exception] documents the purpose of that library in the section
[Motivation] as follows:

.N[
Traditionally, when using exceptions to report failures, the throw site:

* creates an exception object of the appropriate type, and
* stuffs it with data relevant to the detected error.

A higher context in the program contains a catch statement which:

* selects failures based on exception types, and
* inspects exception objects for data required to deal with the problem.

The main issue with this "traditional" approach is that often, the data
available at the point of the throw is insufficient for the catch site to handle
the failure.
]

---
template: plain
name: stl_quickly_and_some_boost
header: ## STL

---------------------------------------------------------------------------

* [STL Containers (recap)			](#stl_containers_recap)
* [STL Container Adapters			](#stl_container_adapters)
* [C++11: New Containers			](#cpp11_new_containers)
* [STL Iterators (recap)			](#stl_iterators_recap)
* [STL algorithms (recap)			](#stl_algorithms_recap)
* [C++11: New Algorithms			](#cpp11_new_algorithms)
* [Boost: Range					](#boost_range)
* [Boost: Algorithm				](#boost_algorithm)
* [C++11: Binders				](#cpp11_bind)

---------------------------------------------------------------------------

---
template: plain
name: stl_containers_recap
header: ### STL Containers (recap)

The STL and its template-based containers are at the heart of reusable library
components standardized with C++98 (besides character strings and I/O-streams).

While there originally where

* three sequential containers, and

* four associative containers,

**C++11** had extended this by

* two more to a **total of five sequential containers**, and

* four more to a **total of eight associative containers**.

---
template: plain
name: sequential_containers
header: #### Sequential Containers

Sequential containers more or less reflect typical basic data structures:

[`std::array`]:        http://en.cppreference.com/w/cpp/container/array
[`std::deque`]:        http://en.cppreference.com/w/cpp/container/deque
[`std::forward_list`]: http://en.cppreference.com/w/cpp/container/forward_list
[`std::list`]:         http://en.cppreference.com/w/cpp/container/list
[`std::vector`]:       http://en.cppreference.com/w/cpp/container/vector

* Contiguous memory …

  * … of fixed size: [`std::array`] (new in C++11)

  * … with heap allocation: [`std::vector`]

* Lists were elements point to each other …

  * … singly linked: [`std::forward_list`] (new in C++11)

  * … doubly linked: [`std::list`]

* Finally a mix of both in form of …

  * … adjacent memory in chunks: [`std::deque`]._[]

.F[:
Abbreviating *Double Ended Queue* but pronounced as "deck".
]

---
template: linkinfo
graphic: STL-SequenceContainers
name: seq_container_specification
header: ##### Sequence Containers Specification

Like the original STL documentation, all C++ standards since C++98

* specify STL containers not by their data structure,

* but supported operations._[] and performance guarantees.

From these the data structure can usually be guessed.

.F[:
As a general rule, operations missing from a given container class will have
no efficient implementation.
]


---
template: plain
name: seq_containers_selection
header: ##### Choosing from Sequential Containers

The choice largely depends on the required operations and their performance.

* When **size can be fixed at compile time**, `std::array` is best.._[]

* If **insertions and extractions need to occur at both or at different ends**,
  this leaves `std::list` and `std::deque` …

* … otherwise `std::vector` would be **a good default choice**.

* Furthermore `std::array` and `std::vector` are the only to choose from when
  **memory layout compatible to native arrays** is mandatory.

* If **random access is required** `std::array`, `std::vector` and `std::deque`
  are the candidates …

* … otherwise, if **insertions and extractions need to be efficient
  everywhere** `std::list` and `std::forward_list`.
  
.F[:
The picture is slightly different if only the *maximum size* can be fixed at
compile time: depending on what is to be stored, an `std::array` may rule out
itself when there is no way to tell "valid" from "invalid" elements and there
is no suitable (default) constructor for the latter ones.
]

---
template: plain
name: associative_containers
header: #### Associative Containers

Associative containers can be grouped around three dimensions:

* Whether they contain **a key value pair or just a key**:

  * `map`-types versus `set`-types

* Whether **duplicate keys are allowed**:

  * `multi`-types versus the others.

* Whether the **underlying data structures is hash-based or a binary tree**:

  * `unordered`-types versus the others.

Viewed pragmatically the data structure rather impacts the following:

* Need lookups be as fast as possible (O(1) even for huge collections)?
* Will there be sequential processing with preferred order of traversal?

If the first is more important as the second, prefer hash-based variants, if
vice versa the tree-based ones.

---
template: linkinfo
graphic: STL-AssociativeContainers
name: assoc_container_specification
header: ##### Associative Containers Specification

The main difference between tree- and hash-based containers is:

* Lookup of keys (elements) with O(log<sub>2</sub>(N)) vs. O(1) performance.

* Requirement of **less-than**-comparision vs. **equal-to**-comparison and
hash-function.._[]

.F[:
If they exist for the element type, `operator<` or `operator==` respectively are
used by default. Otherwise (or to replace the default) comparisons must be named
in the type or the constructor. Hash functions are defined for all basic types
and many standard library classes too.
]

---
template: plain
name: stl_container_adapters
header: ### STL Container Adapters

There are a number of use patterns for which the standard STL containers are
more powerful as desirable – or in other words:

* where some operations should be completely taken away,

* or be made available in a limited or different form.

This is the problem that adapters are designed to solve.

---
template: plain
name: stl_stack_adapter
header: #### Stacks

[`std::stack`]: http://en.cppreference.com/w/cpp/container/stack

The [`std::stack`] adapts a container so that insertions and deletions can take
place only at the same end.

* The default underlying container is an `std::deque` but also `std::vector` or
  `std::list` can be chosen.._[]

* Instead of "back" and "front" as conventionally used for a sequential
  container

  * the most recent element (inserted last) is named "top", and

  * at that end elements are simply "push"-ed and "pop"-ed.

* Also there is no iterator style (or other) interface to iterate over the whole
  content.

.F[:
Interestingly an `std::forward_list` cannot be adapted to a stack, though it
implements perfect stack semantics. This is because a stack adapter expects to
work at the "back"-side of its underlying container, not the "front"-side that
the singly linked list exposes.
]

---
template: plain
name: stl_stack_example
header: ##### Stack Code Examples

The following shows a possible way to fill …
```
std::stack<int> data;
…
int x;
while (std::cin >> x)
    data.push(x);
```

… and to extract from a stack;
```
while (!data.empty()) {
    std::cout << data.top() << ' ';
    data.pop();
}
```

---
template: plain
name: stl_queue_adapter
header: #### Queues

[`std::queue`]: http://en.cppreference.com/w/cpp/container/queue

The [`std::queue`] adapts a container so that insertions and deletions can take
place only at different ends.

* The default underlying container is an `std::deque` but also `std::list` can
  be chosen.

* The "back" and "front" ends as conventionally used for a sequential container
  are kept, with

  * the most recent element (inserted last) is "push"-ed to the "back", and

  * the least recent element (inserted longest ago) may be "pop"-ed from the
    "front".

* Also there is no iterator style (or other) interface to iterate over the whole
  content.

---
template: plain
name: stl_queue_example
header: ##### Queue Code Examples

The following shows a possible way to fill …
```
std::queue<int> data;
…
int x;
while (std::cin >> x)
    data.push(x);
```

… and to extract from a queue;
```
while (!data.empty()) {
    std::cout << data.front() << ' ';
    data.pop();
}
```

---
template: plain
name: stl_priority_queue_adapter
header: #### Priority Queues

[`std::priority_queue`]: http://en.cppreference.com/w/cpp/container/priority_queue

Considering its core interface an [`std::priority_queue`] is similar to an
`std::queue`.

* The default underlying container is an `std::vector`.

* Elements are "push"-ed and "pop"-ed …

  * … while any extraction takes place on the "top" …

  * … which is the largest element currently contained.

* For flexibility the sort criteria may be specified at construction time.

.N[
Priority queues can be – and probably are – implemented based on the STL
algorithms for managing heap data structures.._[]
]

.F[:
Here the term heap is used differently from its usual meaning, which is to refer
to the *free store area* of the (technical) execution model.
]

---
template: plain
name: stl_priority_queue_example
header: ##### Priority Queue Code Examples

A priority queue storing `int`-s in the default order (extract greatest first)
…
```
std::priority_queue<int> pq1;
```

… which is the same as specifying all defaults explicit …
```
std::priority_queue<int, std::vector<int>, std::less<int>> pq1;
```

… and vice versa (extracts smallest first):._[]
```
std::priority_queue<int>, std::vector<int>, std::greater<int>> pq2;
```

.F[:
As the sort functor is the third template argument, the second (the container on
which the priority queue is based) must be specified too, even if the default
applies.
]

.N[
Note that the comparison functor orders by what goes to the top **last**!
]

---
template: plain
name: cpp11_new_containers
header: ### C++11: New Containers

[`std::array`]:        http://en.cppreference.com/w/cpp/container/array
[`std::forward_list`]: http://en.cppreference.com/w/cpp/container/forward_list
[`std::set`]: http://en.cppreference.com/w/cpp/container/set
[`std::unordered_set`]: http://en.cppreference.com/w/cpp/container/unordered_set
[`std::multiset`]: http://en.cppreference.com/w/cpp/container/multiset
[`std::unordered_multiset`]: http://en.cppreference.com/w/cpp/container/unordered_multiset
[`std::map`]: http://en.cppreference.com/w/cpp/container/map
[`std::unordered_map`]: http://en.cppreference.com/w/cpp/container/unordered_map
[`std::multimap`]: http://en.cppreference.com/w/cpp/container/multimap
[`std::unordered_multimap`]: http://en.cppreference.com/w/cpp/container/unordered_multimap
[`std::bitset`]: http://en.cppreference.com/w/cpp/utility/bitset

The following were introduced with C++11:

* [`std::array`] – a wrapper around native arrays

* [`std::forward_list`] – a singly linked list

* [`std::unordered_set`] – the hash-based version of [`std::set`]

* [`std::unordered_multiset`] – the hash-based version of [`std::multiset`]

* [`std::unordered_map`] – the hash-based version of [`std::map`]

* [`std::unordered_multimap`] – the hash-based version of [`std::multimap`]

* [`std::bitset`] is not a new container._[] but has been slightly extended.

The iterator interface of all existing containers has been extended with the
member functions `cbegin()`, `cend()`, `crbegin()`, and `crend()` to obtain
`const_iterator`s from non-`const` containers.

.F[:
From a language lawyer point of view an `std::bitset bs` may not even be called
"container" as it misses the standard iterator interface – only counting
loops (`for (i = 0; i < bs.size()`; ++i) …`) are supported.
]

---
template: plain
name: std_array
header: #### std::array

[`std::array`]: http://en.cppreference.com/w/cpp/container/array

The [`std::array`] wrapper makes native arrays look more like standard
conforming containers.  It has to be instantiated with a type and a size
argument:

```
std::array<double, 50> data;
```

The wrapper adds:

* Standard embedded type definitions like `size_type`, `value_type` etc.

* Standard member functions like `size()`, `empty()` etc.

* Everything required for walking over the content using the standard iterator
  interface.

The latter not only makes iterating over native arrays no more different from
the other containers. By that it also enables range based for loops.._[]

.F[:
As native arrays are compatible with range based loops too, wrapping into an
`std::array` is not necessary if this is were the only reason. Especially as
the slight inconvenience is introduced that the size argument cannot be omitted
even if the array definition is combined with an initialization.
]

---
template: plain
name: std_forward_list
header: #### std::forward_list

[`std::forward_list`]: http://en.cppreference.com/w/cpp/container/forward_list
[`std::list`]: http://en.cppreference.com/w/cpp/container/forward_list

This container makes a minimum-overhead, singly-linked list available.

It has the following differences to the probably well-known [`std::list`]:

* An [`std::forward_list`] does not know its size – so testing for contained
  elements must be with `empty()`, not `size() == 0`.

* Insertion and extraction take place at the "front"-side, hence

  * member functions `front`, `push_front`, and `pop_front` are available

  * but not their counterparts working at the "back"-side.

* When walking over the content with an iterator, it does not allow to insert
  new elements at the iterator position but only after it.

  * This is technically easy to explain as a minimum-overhead iterator can not
    know the element prior to the one it refers to.

  * Therefore the member function implementing insertion is not called `insert`
    but `insert_after`.

---
template: plain
name: hash_based_containers
header: #### Hash-based Containers

Hash-based containers will improve lookup-performance at the price that the
order, when iterating over the container, is not predictable:

* With a decent hash function most any key will be found in O(1) time – or a
  decision made that a key does not exist.

* When the container is filled by incrementally adding more elements over time,
  it also will extend its reserved space incrementally and therefore its
  elements must more or less frequently be re-hashed.

* Differently from `std::vector` iterators keep valid even when elements are
  rehashed.

* Though no specific order can be expected when walking over a hash-based
  container, elements with the same key follow each other (as elements with
  the same hash-value will do).

* Elements of a set or keys of a map are not required to implement `operator<`
  but `operator==`.._[]

.F[:
Though probably not to expect in practice this could have subtle effects if an
ordered container were exchanged with its unordered cousin or vice versa.
]

---
template: plain
name: boost_unordered
header: #### Boost: Unordered

[Boost.Unordered]: http://www.boost.org/doc/libs/release/doc/html/unordered.html

If a C++ implementation does not (yet) make hash-based containers available
[Boost.Unordered] may be used as drop-in replacement.

.N[
The most important difference is that the standard containers are in namespace
`std` while their Boost couterparts are in namespace `boost`.
]

---
template: plain
name: boost_bimap
header: #### Boost: BiMap

[Boost.Bimap]: http://www.boost.org/doc/libs/release/libs/bimap/doc/html/index.html

[Boost.Bimap] allows bidirectional key-value lookup.

```
class IP { … };   // classes for objects to map bidirectionally
class Host { … }; // to each other (also works with built-in types)
…
typedef boost::bimap<IP, Host> IP_to_Host; // define type ...
IP_to_Host nameservice;                    // ... and object
…
// fill nameservice (bidirectional map) with content:
nameservice.insert(IP_to_Host::value_type(IP(…), Host(…)));
nameservice.insert(IP_to_Host::value_type(IP(…), Host(…)));
…
// lookup now works both ways:
… nameservice.left.find(IP(…)) …    // lookup entry via IP-Number
… nameservice.right.find(Host(…)) … // lookup entry via Host-Name
```

The interface to

* `nameservice.left` is like that of a `map<IP, Host>`;

* `nameservice.right` is like that of a `map<Host, IP>`.

---
template: plain
name: boost_bimap
header: #### Boost: MultiIndex

[Boost.MultiIndex]: http://www.boost.org/doc/libs/release/libs/multi_index/doc/index.html
[Tutorial]: http://www.boost.org/doc/libs/release/libs/multi_index/doc/tutorial/index.html

[Boost.MultiIndex] generalises the idea of a table-like structure with any
number of rows and a fixed number of columns, with a given type and some pre-defined
properties like

* uniqueness and

* sort order.

In its implementation it uses a number of non-trivial meta programming
features, so, from the user perspective, the best approach is probably to use
in "cook-book style", deriving from and extending the examples in the
[Tutorial].

---
template: plain
name: boost_property_tree
header: #### Boost: Property Tree

[Boost.Property_Tree]: http://www.boost.org/doc/libs/release/doc/html/property_tree.html

[Boost.Property_Tree] is a recursive data structure.

A node (starting with the single root node)

* has some data value (typically an `std::string`)

* and a list of children (empty for leaf nodes),

  * each of which holds a key (typically an `std::string`)

  * and a sub-tree starting with a node that

   * has some data value

   * and a list of children

     * each of which holds a key

     * and a sub-tree starting with …

---
template: plain
header: ##### Property Tree (cont.)

[JSON]: http://en.wikipedia.org/wiki/JSON

When represented in main memory a property tree can be navigated
programmatically (e.g. searched for sub-notes).

Besides that in can be made persistent in an external representation, i.e.
written to a file and read back in a number of serialization formats:

* JSON (JavaScript Object Notation)

* Info-File format (similar to JSON with lesser punctuation)

* Ini-File format (as widely used by MS-Windows "in the old days")

* XML (with a fixed conversion schema, no generic DTD or document object model)

.N[
Therefore property trees are well suited for storing configuration data or state
information between consecutive program executions, though that's not their sole
possible use.
]

---
template: plain
name: stl_iterators_recap
header: ### STL Iterators (recap)

[C++ Algorithms]:     	   http://en.cppreference.com/w/cpp/algorithm
[C++ Containers]:          http://en.cppreference.com/w/cpp/container
[C++ Iterator Categories]: http://en.cppreference.com/w/cpp/iterator
[Iterators]:               http://en.wikipedia.org/wiki/Iterator_pattern

The STL was designed around the idea that the glue between [C++ Containers]
and [C++ Algorithms] should be provided by [Iterators] which were further
categorized by their capabilities, leading to [C++ Iterator Categories]:

* **Input- and Output-Iterators** – same operations as Forward-Iterators (see
  next) but with restrictions on the order of operations.

* **Forward-Iterators** – comparable to each other, `operator++` in pre- and
  postfix version, `operator*` for dereferencing.

* **Bidirectional-Iterators** – in addition `operator--` in pre- and postfix
  version.

* **Random-Access-Iterators** – in addition `operator+=` and `operator-=` to
  increment and decrement in steps of more than one and `operator-` to determine
  the distance between two iterators.

.N.center[
**Containers** document the iterator category they **provide**  
and **Algorithms** the category they **require**.
]

---
template: plain
name: stl_iterators_performance
header: #### STL Iterators Efficiency

[_STLP_DEBUG for STLport]: http://www.stlport.com/doc/debug_mode.html

To allow a maximally efficient implementation of iterators with respect to

* Memory Footprint and

* Runtime Performance

safety requirements were not cast into any of the C++ standards but left as a
*Quality of Implementation* (QoI) issue.._[]

.F[:
What is frequently misunderstood is that implementations actually **can** prefer
safety over efficiency; some versions of the STL have special macros that can be
defined to enable additional tests, e.g.  [_STLP_DEBUG for STLport]. If other
vendors (or free implementations) of Standard C++ do not exploit the leeway
given by the standard to add "safety" features, then presumably because there is
not that much pressure from the respective clients to have such features … or
at least not at the price to pay for it in terms of lost efficiency.
]

.N[
For most containers an iterator can be as efficient as a pointer.
]

Walking through all elements of a container with an iterator does

* not **require** any large support data structure, and

* **may** map to very few machine instructions at assembler level.

---
template: linkinfo
graphic: STL-IteratorUsages
name: iterators_as_glue
header: #### Iterators Interfacing Containers to Algorithms

Iterators provide the "glue" that interfaces STL-Containers to STL-Algorithms.

* To algorithms *element ranges* are specified, using **asymmetric bounds**.

* Searching algorithms return iterator to found element or end of range.

* Removals are not physical but re-arrange elements.

* Filling algorithms indicate next available position.

---
template: plain
name: stl_algorithms_recap
header: ### STL Algorithms (recap)

Algorithms originally supplied when the STL was standardized with C++98 are too
numerous to give them full coverage here.

Instead refer to a good documentation source like named below or equivalent:

* http://en.cppreference.com/w/cpp/algorithm

* http://www.cplusplus.com/reference/algorithm/

The following only recapitulates some of the systematic approach and after this
highlights a few C++11 extensions.

---
template: plain
name: iterator_container_interface
header: #### Iterator Interface to Containers

Algorithms usually deal with containers but abstract that fact away by taking
two iterator arguments:
```
std::vector<int> data;
…
// add all values in container
const auto n = std::accumulate(data.begin(), data.end(), 0);
```

This may seem as a minor inconvenience but easily allows for subranges without
the need for specialized algorithms:
```
assert(data.size() > 3);
// add values in container except the first two and the last
const auto n = std::accumulate(data.begin()+2, data.end()-1, 0);
```

.N[
Note that a typical requirement of algorithms is that: of the two iterators
specifying the range the second must be *reachable* from the first.
]

This means, after the first is incremented often enough it must – while staying
within the container bounds – compare equal to the second.

---
template: plain
name: iterator_generic_interface
header: #### Generic Iterator Interface

Another reason that makes the iterator interface to algorithms powerful is that
iterators are not required to connect to containers.

.N[
It can make sense to define a class that exposes the same interface as an 
iterator while actually calculating values on the run.
]

```
class Iota
    : public std::iterator<std::input_iterator_tag, int> {
    int i, s;
public:
    Iota(int i_ = 0, int s_ = 1) : i(i_), s(s_) {}
    int operator*() { return i; }
    Iota operator++() { return Iota(i += s, s); }
    Iota operator++(int) { i += s; return Iota(i - s, s); }
};
```

Given the above class a container can be filled with a number range:
```
std::copy_n(Iota(), 20, std::back_inserter(data));
std::copy_n(Iota(10, 3), 20, std::back_inserter(data));
```

---
template: plain
name: stl_algorithm_families
header: #### Algorithm Families

[`std::back_insert_iterator`]: http://en.cppreference.com/w/cpp/iterator/back_insert_iterator
[`std::front_insert_iterator`]: http://en.cppreference.com/w/cpp/iterator/front_insert_iterator
[`std::insert_iterator`]: http://en.cppreference.com/w/cpp/iterator/insert_iterator
[`std::ostream_iterator`]: http://en.cppreference.com/w/cpp/iterator/ostream_iterator

To the degree to which it makes sense STL algorithms come in families:

* A *plain algorithm* (say: `std::remove`) does its work modifying a container,
  basing its decision (which elements to remove) on a fixed value.

* The `_copy`-version (i.e. `std::remove_copy`) leaves the original container
  unmodified, storing the result to another container.._[]

* The `_if`-version (i.e. `std::remove_if`) generalizes the predicate through
  using a *Callable* as last argument (function, functor, lambda).

* If both of the above versions exist they will also be found combined into a
  `_copy_if` version (i.e. `std::remove_copy_if`).

.F[:
The target for this operation again is specified with an *iterator* that gets
used as [Output Iterator](#stl_iterators_recap); usually it will be kind of an
inserter, i.e. [`std::back_insert_iterator`] or [`std::front_insert_iterator`]
for sequential containers, [`std::insert_iterator`] for associative containers,
or [`std::ostream_iterator`] for output streams.
]
  
---
template: plain
name: algorithms_for_arrays
header: #### Using Algorithms on Native Array

With native pointers used as iterators, all of the STL algorithms can also be
used to process native arrays.

.N[
There is price to pay: any algorithm that logically removes values cannot make
the array smaller – so it returns the new end.
]

```
int data[1000], *data_end = data;
… // fill with values, make data_end point behind the last
std::sort(data, data_end);               // first sort then ...
data_end = std::unique(data, data_end);  // ... remove duplicates
```

Alternatively the `std::array` wrapper could be applied:
```
std::array<int, 1000> data;
auto data_end = data.begin();
… // fill and make data_end to refer after the last ...
std::sort(data.begin(), data_end));
data_end = std::unique(data.begin(), data_end);
```

---
template: plain
name: resizing_after_removal
header: #### Return Values from Removals

Generally algorithms that logically remove elements from a container return the
"new end".

This is also true if the physical size of the underlying container could be
made smaller, like for the sequential STL containers:
```
// assuming a container x with elements of type int:
auto new_end = std::remove_if(x.begin(), x.end(),
                              [](int e) { return (e < 42); });
```

Physically reducing the container size must happen explicitly:
```
x.erase(new_end, x.end()); 
```

---
template: plain
name: resizing_after_removal
header: #### Return Values from Filling

Many algorithms that fill a container – in case of families particularly the
`_copy`-version – return an iterator pointing after the last element copied to
the result.

This is often useful, especially when the filling state of a native array needs
to be tracked:._[]
```
const int N = 32767;
static_assert(ckdiv2(N+1), "N must be a power of two minus one!");
int data[N], *data_end = data;
for (int n = 1, i = (N+1)/2; i > 0; ++n, i /= 2)
    data_end = std::fill_n(data_end, i, n);
```

.F[:
To figure out how exactly that code initializes the container with which values
is left as an exercise for the reader :-) … if not from a code analysis then
go and wrap the above fragment into a `main`-function, compile, run, and look at
the output … (maybe reduce `N` to much smaller values, say 7, 15, 31, …).
]

---
template: plain
name: cpp11_new_algorithms
header: ### C++11: New Algorithms

Again the following does not intend to be exhaustive, instead it should just
shortly highlight C++11 additions for those who know STL algorithms quite well
from C++98.

* The largest group is the one in which most algorithms start with `is_`. These
  check for certain properties of a container content.._[]

* A few algorithms have probably been added because a substantial number of
  people found them "missing".

  * In one subgroup the new algorithms will actually improve performance.

  * Others could have been well expressed with the available algorithms but an
    algorithm with an expressive name makes the intent clearer.

.F[:
Or rather sequences, as the interface is of course through iterators, so no
underlying container needs to be exposed.
]

---
template: plain
name: container_searching
header: #### New Ways to Search through Containers

The following algorithms take a predicate as argument to check for **each**
container element, but all have the chance to shortcut the evaluation:

* `std::all_of` – can return `false` the first time the predicate is `false`

* `std::any_of` – can return `true` the first time the predicate is `true`

* `std::none_of` – can return `false` the first time the predicate is `true`

.N[
Though any of the above can be written in terms of any other, it is usually
clearest to express the intent with the fewest negations.
]

Compare:._F[]
```
std::none_of(x.begin(), x.end(), [](int v) { return (v > 0); }
!std::any_of(x.begin(), x.end(), [](int v) { return (v > 0); }
std::all_of(x.begin(), x.end(), [](int v) { return !(v > 0); }
```

.F[:
For a good test whether a condition is clearly expressed imagine you read it out
to someone at the telephone. Which one of these do you think will be understood
then without any doubt or asking back?
]

---
template: plain
name: container_filling
header: #### New Ways to Fill Containers

A new algorithm to copy from one container to another one allows to specify the
number of elements instead of an end iterator.

This allows sometime for easier calculations:
```
const std::size_t Ndata = 50, Nresult = 20;
int data[Ndata], *data_filled = data;
int result[Nresult], *result_filled = result;
… // copy to data, assume it is finally filled up to data_filled
… // also assume result has now content up to result_filled
…
// copy from data to result until data exhausted or result full:
const auto available = data_filled - data;
const auto freespace = result + Nresult - result_filled;
std::copy_n(data, std::min(available, freespace), result_filled);
```

Also it is now easily possible to fill a container with increasing values:._[]
```
std::iota(data, data+Ndata, 1); // fills in: 1 2 3 4 ...
```

.F[:
Note that `std::iota` **expects container elements to exist**. E.g. if an
`std::vector` had to be filled it must be resized first.
]

---

template: plain
name: container_copysearch
header: #### Algorithms Adding Negation

Elements to be copied from one container to another one can now be selected with
a predicate.

Given two sequential containers `x` and `result` with element type `T` the
following code would do this:._[]
```
std::copy_if(x.begin(), x.end(), std::back_inserter(result),
             [](T elem) {
                 return …; // whatever needs to be checked for elem
             });
```

.F[:
As `T` is handed to the lambda by value, it must be copyable; alternatively the
argument can be handed over as (`const`) reference.
]

With a negated predicate `std::remove_copy_if` had the same effect.

Similarly when searching for the first container element that does not have a
given property, checked with a predicate:
```
… std::find_if_not(x.begin(), x.end(), [](T elem) { return …; });
```

Again, `std::find_if` with a negated predicate did the same search.

---
template: plain
name: algo_improve_performance
header: #### Algorithms Improving Performance

It is now possible to search for the minimum and maximum value at the same time,
passing over the sequence only once with fewer comparisons:
```
auto result_it = std::minmax_sequence(x.begin(), x.end());
… result_it.first … // iterator denoting minimum element
… result_it.last … // iterator denoting maximum element
```

.W[
Of course, the iterators returned must not be dereferenced without a prior test
if the sequence might have been empty!
]

There is also a simpler version returning a reference to two variables:
```
int a, b;
… // fill in values
auto result = std::min_max(a, b);
… result.first … // reference to variable holding the smaller value
… result.last … // reference to variable holding the larger value
// or store into two separate variables:
int min, max;
std::tie(min, max) = std::minmax(a, b);
```

---
template: plain
name: boost_range
header: #### Boost: Range

[Boost.Range]: http://www.boost.org/doc/libs/release/libs/range/doc/html/index.html

[Boost.Range] extends the basic idea to combine iterators to pairs – called
ranges – with the goal to eliminate the need to always have to supply two
arguments when just a single container is involved.._[]

* Additional algorithms accept these ranges instead of the separate arguments
  their STL counterparts require.

* The concept of ranges is further extended so that algorithms can be glued
  together with a high degree of flexibility.

.F[:
Because the two arguments style adopted by the original STL has the advantage
that subranges do not require additional algorithms, ranges from this library
can of course not only be constructed from containers (taking `begin()` and
`end()` as range) but also from two container iterators!
]

---
template: plain
name: boost_algorithm
header: #### Boost: Algorithm

[Boost.Algorithm]: http://www.boost.org/doc/libs/release/libs/algorithm/doc/html/index.htm

[Boost.Algorithm] is a collection of algorithms to extending the STL.

.N[
Parts of this collection have been standardized with C++11, others are intended
to become part of C++14, some will still stay "Boost only".
]

---
template: plain
name: cpp11_bind
header: ### C++11: Binders (`std::bind`)

Binders are a mechanism that may or may not._[] be preferred over lambdas in
simple situations where **a new function is created from an existing one** and

* either the new function needs fewer arguments because some arguments of the
  existing function will receive fixed values,

* or requires its arguments specified in a different order from a given call
  (which may e.g. be dictated by an algorithm to which the resulting function
  is handed over as argument),

* or both.

.F[:
Whether or not to use binders or stick purely with lambdas seems to be mainly a
matter of taste. 
]

---
template: plain
name: cpp11_bind_example1
header: #### Reducing Number of Arguments with `std::bind`

  [Boost.Lambda placeholders]: http://www.boost.org/doc/libs/1_55_0/doc/html/lambda/le_in_details.html#lambda.placeholders
  [Boost.Bind placeholders]: http://www.boost.org/doc/libs/release/boost/bind/placeholders.hpp

In the following `std::bind` adapts the function `bar`, which has three
arguments, to be called from inside `foo` with only two arguments and the
middle argument fixed to the square root of two:
```
#include <functional>
using namespace std::placeholders;
extern void bar(int, double, const char *);
…
foo(std::bind(bar, _1, std::sqrt(2.0), _2));
```

.N[
Note that the placeholders can be used unqualified here because they have been
imported from their (sub-) namespace.._[]
]

.F[:
Because of the identical names making placeholders visible as `_1`, `_2` etc.
may collide with [Boost.Lambda placeholders] or [Boost.Bind placeholders].
In general special care must be taken when `std::bind` is mixed with other
libraries that use such placeholder names too for their own purpose.
]

The highest placeholder number used (`_2` above) determines the (lower bound of
the) argument count of the function returned from `std::bind`.

---
template: plain
name: cpp11_bind_example2
header: #### Changing Order of Arguments with `std::bind`

In the following `std::bind` adapts the function `baz`, which has two arguments
to be called from inside `foo` with the arguments reversed:
```
#include <functional>
using namespace std::placeholders;
extern void baz(const char *, int);
…
foo(std::bind(baz, _2, _1));
```

It is also possible to drop arguments completely:._[]
```
foo(std::bind(baz, _2, 42));
```

.N[
In both cases `std::bind` returns a function that needs to be called with
two arguments, determined by the placeholder `_2`.._[]
]

.F[:
More exactly, the placeholder `_X` with the largest value of `X` determines
that (at least) a number of `X` arguments are required to call the function
returned from `std::bind`. Supplying lesser arguments in a call will result
in a compilation error.
]

---
template: plain
name: cpp11_bind_example2
header: #### Binding Member Functions

It is also possible to use `std::bind` for objects and their members – shown
here only for member functions but it works the same for any accessible member
data.

The only thing special here is that objects are bound as if they were the
member function's first argument.._[]

.F[:
In other words: more or less binding simply makes explicit what is happening
anyway ("behind the scenes") whenever a member function is called …
]

The next two examples assume the following class:
```
class MyClass {
    …
    void f(int);
    void cf(int) const;
    int g(char) const;
};
```

.N[
To make the following examples applicable in a cookbook-style, they introduce
[Reference Wrappers](#cpp11_ref_cref) which are more fully covered only later.
]

---
template: plain
name: cpp11_bind_example2_1
header: #### Binding Member Functions to Same Object

It is possible to bind the same object to various arguments:._[]
```
MyClass mc;
std::vector<int> data;
… // fill data
std::for_each(data.begin(), data.end(),
              std::bind(&MyClass::cf, mc, _1));
```

.F[:
Note that `std::for_each` was chosen here only because it constitutes a very
simple example. Especially given range-based loops in C++11 the above could
well be replaced with: `for (auto e : data) mc.cf(e);`
]

As `std::bind` uses value arguments the use of a *reference wrapper*
like `std::cref` may help to improve performance …
```
std::for_each(data.begin(), data.end(),
              std::bind(&MyClass::cf, std::cref(mc), _1));
```

… or `std::ref` may even be necessary to make modifications visible:
```
std::for_each(data.begin(), data.end(),
              std::bind(&MyClass::f, std::ref(mc), _1));
```

---
template: plain
name: cpp11_bind_example2_2
header: #### Binding Member Functions to Different Objects

Also various objects may be bound to call the same member function:._[]
```
std::vector<MyClass> objs;
… // fill objs
auto n = std::accumulate(objs.begin(), objs.end(), 0,
              std::bind(&MyClass::g, _1, 'a'));
…
std::list<int> result;
std::transform(objs.begin(), objs.end(),
               std::back_inserter(result),
               std::bind(&MyClass::g, _1, 'z'));
```

.F[:
Note that these examples are different from the ones on the previous slide as
`_1`  now refers to the object from the container and triggers generating the
appropriate expression template, so no reference wrapper is required here.
]

Rewritten to range based loops the above is equivalent to:
```
int n{0};
for (const auto &e : objs) n += e.g('a');
…
for (const auto &e : objs) result.push_back(e.g('z'));
```

---
template: plain
name: cpp11_bind_example2_3
header: #### Binding Member of Different Objects with Different Arguments

Generally speaking, possible limitations are not so much imposed by `std::bind`
as by what algorithms exist.._[]

.F[:
Not to say: The possibly limited knowledge of developers with respect to the
algorithms available in C++11 and Boost … well, that's not you as you're here
now :-)
]

As there exists a variant of `std::transform` to process two containers in
parallel, a selected member function may also be applied to **different**
objects with **different** arguments:
```
std::string data;
… // fill data;
assert(data.size() >= objs.size());
std::transform(objs.begin(), objs.end(), data.begin(),
               std::back_inserter(result),
               std::bind(&MyClass::g, _1, _2));
```

Translated into a range-base loop the above is equivalent to:
```
auto z = data.cbegin();
for (auto &e : objs) result.push_back(e.g(*z++));
```

---
template: plain
name: bind_vs_lambda
header: #### `std::bind` vs. C++11 Lambdas

Everything that can be achieved with `std::bind` can be achieved with lambdas
too.._[]

.F[:
With C++11 lambdas as well as with Boost lambdas though the topic will only be
discussed for the former here.
]

The most visible difference is that with lambdas the argument types are more
explicit:
```
foo([](int _1, const char *_2) { bar(_2, std::sqrt(2), _1); });
foo([](int _1, const char *_2) { baz(_2, _1);               });
foo([](int   , const char *_2) { baz(_2, 42);               });
foo([](int _1, const char *  ) { baz("hello", _1);          });
```

.N[
The above example emphasizes this similarity by using `_1` and `_2` as name for
the formal lambda arguments.
]

Usually such names were rather chosen according to their purpose, like:
```
foo([](int count, const char *name) { baz(name, count); });
```

---
template: plain
name: boost_bind
header: ### Boost: Binders

[Boost.Bind]: http://www.boost.org/doc/libs/release/libs/bind/bind.html

C++11 `std::bind` emerged from [Boost.Bind].

There are few differences most of which are related to lifted restrictions
because C++11 supports true variadic templates.

* With `std::bind` the maximum number of arguments of **the adapted function**
  is essentially unlimited, while

* the maximum number of arguments for the function returned from `std::bind`
  is determined by the highest placeholder number defined in an implementation.

.N[
For `boost::bind` there may be a fixed limit._[] for both, the number of arguments
of the adapted function and the number of arguments of the function returned.
]

.F[:
Whether there is a fixed limit depends on the compiler used and what exactly
is the limit is determined be a configuration step that is run prior to the
installation of Boost. Increasing the default limit typically has a price in
header file size and hence longer compilation time (with negative impacts
probably only for unreasonably large limits).
]

---
template: plain
name: cpp11_ref_cref
header: ## C++11: Reference Wrappers

At many places C++ prefers handling (copies of) values:

* Often this is safer and relieves the developer from the burden of caring about
  aliasing issues or memory ownership.

* Where necessary, references instead of a values can be explicitly chosen.

* In case of library functions the interface sometimes cannot be changed
  easily, here reference wrappers may be inserted instead.

Reference wrappers have already been used in two prior
[examples for `std::bind`](#cpp11_bind_example2_1):

* One such use (`std::cref`) was only to improve performance,._[]

* without the other (`std::ref`) the code wouldn't have worked as intended.

.F[:
Not all uses of `std::cref` are only to improve performance – for classes which
make their objects non-copyable they may be necessary so that the code compiles
in the first place.
]

---
template: plain
name: cpp11_ref_example1
header: ### Reference Wrapper Example (1)

The following function `print` automatically inserts line breaks if otherwise a
given length would be exceeded:
```
void print(std::string word, unsigned maxlen, unsigned &filled) {
    if (filled + word.length() > maxlen) {
        std::cout << '\n';
        filled = 0;
    }
    if (filled > 0) {
        std::cout << ' ';
        ++filled;
    }
    std::cout << word;
    filled += word.length();
}
```

---
template: plain
name: cpp11_ref_example2
header: ### Reference Wrapper Example (2)

Assuming there are a number of words of type `std::string` in a sequential
container `text`, the above function could be adapted to be used with
`std::for_each`:
```
unsigned line_filled = 0;
auto p80 = std::bind(print, 80, line_filled);
std::for_each(text.begin(), text.end(), p80);
```

A first test shows that it works as expected. But it fails if the words come
in two containers `text` and `moretext` where the second should continue
printing in the last line of the first, if it's only partially filled:
```
std::for_each(moretext.begin(), moretext.end(), p80);
```

.W[
The reason is that `std::bind` takes its arguments by value, so the reference
to `filled` which is modified actually isn't `line_filled` but a copy of it in
the generated (invisible) binder object.
]

---
template: plain
name: cpp11_ref_example3
header: ### Reference Wrapper Example (3)

[Boost.Ref]: http://www.boost.org/doc/libs/release/doc/html/ref.html

The solution is to connect `line_filled` through a reference wrapper.

This is most easily done by the helper function `std::ref`:._[]
```
auto p80 = std::bind(print, 80, std::ref(line_filled));
```

There is also a *constant reference* version `std::cref`, providing a solution
for constant but non-copyable types that need to be bound:
```
class MyClass {
    …
    MyClass(const MyClass &) = delete;
    …
};
…
MyClass obj;
void foo(…, const MyClass &arg, …);
… std::bind(foo, …, obj, …) …            // COMPILE ERROR
… std::bind(foo, …, std::cref(obj), …) … // OK
```

.F[:
Of course reference wrappers are not a recent invention of C++11 but had been
available via [Boost.Ref] since long … (only, due to the close similarity to
C++11 they do not receive a slide of their own here).
]

---
template: plain
name: strings_and_regex
header: ## Strings (including Regular Expressions)

--------------------------------------------------------------------------------

* [Library Basics: String			](#string_basics)
* [Regular Expressions				](#cpp11_regular_expressions)

--------------------------------------------------------------------------------

---
template: linkinfo
graphic: CodeUnits_vs_CodePoints
name: string_prelude
header: ### Prelude: Code Units vs. Code Points

The main reason to use strings is to represent "readable" text.

The challenges in the mapping

* of code units (raw storage type)

* via code points (often Unicode)

* to perceived characters

needs to be understood!

---
template: linkinfo
graphic: StringBasics
name: string_basics
header: ### Library-Basics – Strings

-------------------------------------------------------------------------------

* [Classes (Overview)				](#stdstring_classes)
* [C Compatibility				](#stdstring_c_compatibility)
* [Efficiency Considerations			](#stdstring_efficiency)
* [Optional "Copy On Write"			](#stdstring_cow)

-------------------------------------------------------------------------------

* [Basic Operations				](#stdstring_basicops)
* [More Operations (Overview)			](#stdstring_moreops)
* [Conversions to/from Arithmetic Types		](#stdstring_numconv)
* [Input and Output                    		](#stdstring_io)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: StringBasics
section: Classes
name: stdstring_classes
header: #### Classes (Overview)

The classes for character strings `std::string` and `std::wstring` from C++98
were augmented in C++11 with `std::u16string` und `std::u32string`. These are
just type definitions like the following:._[]
```
namespace std {
    typedef basic_string<char> string;      // since C++98
    typedef basic_string<wchar_t> wstring;  // since C++98
    typedef basic_string<char16_t> u16string; // since C++11
    typedef basic_string<char32_t> u32string; // since C++11
}
```

.I[
For more details refer to
http://en.cppreference.com/w/string/
]

.F[:
The type definitions show only half of the truth: other template arguments are a
character traits class and an allocator (memory management policy). Both have
been omitted in the example as they do not change the essential point to make.
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_c_compatibility
header: #### Compatibility with C

[Small Buffer Optimisation (SBO)]: https://akrzemi1.wordpress.com/2014/04/14/common-optimizations/

The class `std::_basic_string` stores characters of a string in contiguous._[]
memory, which has at least the required size, but often is allocated with some
extra space.

The internal representation frequently is via three pointers:

* The address of the first contained character.

* The address of the last (valid) character.

* The address to mark the end of allocated memory (usually one character beyond)

Also on 64-bit architectures (and for strings of 8-bit wide characters)
[Small Buffer Optimisation (SBO)] is common.

.N[
When dealing with the character strings based on the standard string classes
there is no restriction to which characters can be contained (other as in C
where `'\0'` ends the string).
]

.F[:
The C++98 standard left it to the library implementors whether to chose
contiguous or non-contiguous storage, though that freedom is – at least in
effect – removed in C++11.
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_cstr_use
header: ##### Using `std::string` as `const char *`

A C-API expecting a C-style string – for example as name of a file – needs
an address (of the first character) and `'\0'` termination (to mark the end).

The necessary adaption is done by the `c_str()` member function:
```
std::string filename;
…
… // get file name from user (or elsewhere)
…
// open file for reading, using the C-API
FILE *fp = std::fopen(filename.c_str(), "r");
```

The above code is **correct and bears no risk**, as the pointer returned by
`c_str()` (or the memory reachable via it)

* is accessed only **inside** `std::fopen`, this

* does not modify the variable `filename`, and

* therefore any possible heap allocation will not change.

.F[:
If the mode to open the file came from an `std::string` too, of course it needs
to be converted similarily like that:
`… std::fopen( … , openmode.c_str()) …`
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_cstr_risk
header: ##### Risks of Using `c_str()`

It should be understood that when using `c_str()` the memory area accessible via
the returned pointer will have a valid content **only** up to the next modifying
operation of the underlying string object.

.pull-left[
```
std::string s("see me, ");
const char *p = s.c_str();
s += std::string("feel me,");
… // gets s further modified here?
s.append(" touch me, hear me");
```
]

.pull-right[
```
const char *mammamia() {
    std::string local;
    …
    return local.data();  // as
    // of C++11 same as c_str()
}
```
]

Whether the example on the left is problematic depends on what happens at the
section indicated with "`…`", while the code on the right hand side – **with
near to sure probability** – will dereference a pointer to already deallocated
heap memory.

.W[
The above code has a **high potential risk**._[] to access invalid memory,
allocated for quite a different purpose than to store the characters of
the string it once held.
]

---
template: withinfo
graphic: StringBasics
section: C-Compatibility
name: stdstring_cstr
header: ##### Using `const char *` as `std::string`

Turning a classic C-string into an `std::string` object is always automatic,
as it happens as type conversion by a (non-`explicit`) constructor.

.N[
The easiest way to make functions callable with both, `std::string` objects
**and** classic C strings is to use an argument of type `const std::string&`.
]

In terms of the code to be written it will be much more work to provide a number
of overloads._[], e.g. for

* `const char *`,
* `const std::string &`, and
* (maybe) `std::string &&`.

.F[:
On the other hand, each version could then be optimized for its argument type.
]

---
template: withinfo
graphic: StringBasics
section: Efficiency
name: stdstring_efficiency
header: #### Efficiency Considerations

[Small String Optimisation]: http://john-ahlgren.blogspot.de/2012/03/small-string-optimization-and-move.html

Typical measures to improve efficiency of `std::string`-s are:

* Allocating some excess memory at the end.

* Proportionally enlarging the allocation (not a constant number of extra
  characters).

* Especially on 64-Bit hardware: [Small String Optimisation]

.F[:
Proportional here means that when the current allocation doesn't suffice any
more it will be doubled (or made 1.5 or 1.8 times as large). This gives O(1)
performance to algorithms that fill a long character string by appending
single characters to the end. Increasing the allocation by a constant, fixed
amount would yield much worse O(N<sup>2</sup>) performance.
]

---
template: withinfo
graphic: StringBasics
section: May or May not Have COW-Implementation
name: stdstring_cow
header: #### Optional "Copy On Write"

[Copy On Write (COW)]: http://www.gotw.ca/publications/optimizations.htm

This optimisation will especially improve code that hands over `std::string`
objects by value (instead of `const std::string&`).

* Copying the string content will not happen right away:._[]

  * Instead a flag is set to mark the string content as shared, and
  * actually copying the content only if a modification takes place.

* As long as in the shared state only there is only non-modifying access
  to the string content, nothing more needs to happen.

.N[
If a (shared) instance ends its life-time without any modification to the
string content, no copying ever needs to take place.
]

.F[:
[Copy On Write (COW)] "optimisations" have shown substantial disadvantages in
multi-threaded environments: the expected performance improvement often is more
then outweighed by necessary locking mechanisms to guarantee exclusive access of
only one single thread.
]

---
template: withinfo
graphic: StringBasics
section: Basic Operations
name: stdstring_basicops

header: #### Basic Operations

Most of these are intuitive, like

* Assignment with `=`,

* Comparision with `==`, `!=` etc.

* Concatenation with `+` and

* Element Access with `[…]`.

and hence cause never problems

.N[
Code not extremely performance relevant should consider to use `at()` instead of
`operator[]` to avoid undefined behavior in case of out-of-bounds access.
]

---
template: withinfo
graphic: StringBasics
section: Advanced Operations
name: stdstring_moreops
header: #### Overview of More Operations

It is fully intended to model `std::string` with a close resemblance to
`std::vector<char>`. Especially:

* Also `std::string` has the usual iterator interface, 
* making it compatible with all STL algorithms of interest (besides member and
  free functions dealing with the class itself).

It may be a matter of experience – and to slight degree a matter of taste –
what kind of coding style is more comprehensible:

The following fragment reads an `std::string s` from standard input and checks
if it contains nothing else but white-space before further processing.

```
// with std::string member function
if (std::getline(std::cin, s)
 && s.find_first_not_of(" \t") == std::string::npos)) …

// with STL algorithm (and predicate specified as lambda)
if (std::getline(std::cin, s)
 && !std::all_of(s.begin(), s.end(),
                 [](char c) { return (c == ' ' || c == '\t'); })) …
```

---
template: withinfo
graphic: StringBasics
section: Numeric Conversions
name: stdstring_numconv
header: #### Converting between `std::string` and Arithmetic Types

Conversions between character sequences and native arithmetic types (`int`,
`unsigned`, `long`, … `double`) is a frequent necessity.

Often unnecessary complicated, cumbersome, and hence error prone code is used:
```
std::string tmpfilename; // fixed part, followed by sequence number
…
char *cp = const_cast<char*>(tmpfilename.c_str());
while (*cp && !std::isdigit(*cp))
    ++cp;                       // locate first digit
const int num = std::atoi(cp);  // convert digit sequence to int
std::sprintf(cp, "%d", num+1);  // and store back incremented by 1
```

.F[:
If not obvious from reviewing the code, the fragment above has the following
problems:  
**1.** `std::atoi` converts up to the first non-numeric character only (hence a
missing numeric part will not be recognized – though in some cases this might be
rather a feature than a bug).  
**2.** Some else's memory might be silently overwritten if at `cp` not enough
space is available for storing `num` incremented.

]

---
template: plain
name: stdstring_str2num
header: ##### Convert `std::string` into Arithmetic Type

C++11 has introduced a new set of functions:

| Function Name    | Conversion to        | (based on)      |
|:----------------|:---------------------|:----------------|
| `std::strtoi`   | `int`                | `std::strtol`   |
| `std::strtol`   | `long`               | `std::strtol`   |
| `std::strtoll`  | `long long`          | `std::strtoll`  |
| `std::strtoul`  | `unsigned long`      | `std::strtoul`  |
| `std::strtoull` | `unsigned long long` | `std::strtoull` |
| `std::strtof`   | `float`              | `std::strtod`   |
| `std::strtod`   | `double`             | `std::strtod`   |
| `std::strtold`  | `long double`        | `std::strtold`  |

Note that the new set provided is a little bit "richer" as the classic (C)
functions on which it is based.

.I[
For more information see:
http://en.cppreference.com/w/cpp/string/basic_string/stol,
http://en.cppreference.com/w/cpp/string/basic_string/stoul, and
http://en.cppreference.com/w/cpp/string/basic_string/stof.
]

---
template: plain
name: cpp11_string_to_num
header: ### Converting Strings to Numeric Values

[`std::stoi`]: http://en.cppreference.com/w/cpp/string/basic_string/stoi
[`std::stoul`]: http://en.cppreference.com/w/cpp/string/basic_string/stoul
[`std::stod`]: http://en.cppreference.com/w/cpp/string/basic_string/stod

For that purpose individual functions were added carrying the returned type
in their name (some `std::` prefixes omitted for brevity):

  * [`std::stoi`], `…stol`, `…stoll` (returning `int`, `long`, `long long`)
  * [`std::stoul`], `…stoull` (returning `unsigned long`, `unsigned long long`)
  * [`std::stod`], `…stod`, `…stold` (returning `float`, `double`, `long double`))

Typical usage fragments (assuming `std::string s` and `std::size_t p`):
```
… = std::stol(s);     // converts from s to long with base 8,
                      // 10 or 16, automatically determined by
                      // prefix 0, no prefix, or prefix 0x / 0X
… = std::stol(s, &p);    // as before with p holding the index
                         // of the character that stopped the
                         // conversion or std::string::npos
… = std::stol(s, &p, 8);    // as before but always uses base 8
… = std::stol(s, &p, 10);   // ... base 10 ...
… = std::stol(s, &p, 16);   // ... base 16 ...
… = std::stol(s, &p, 36);   // ... up to base 36 (0..9-A..Z)
… = std::stol(s, nullptr, 16); // converts from s with base 16,
                               // stop position not of interest
```

---
template: plain
name: cpp11_num_to_string
header: #### Converting Numeric Values to Strings

To convert arithmetic types into `std::string` C++11 introduced a number of
overloads for the (free) function `std::to_string`:

The various overloads exist because each type has its own conversion, i.e. there
is no dependence on argument type conversions.

Typical usage fragments might look as follows:
```
int i; unsigned u; unsigned long ul; double d;
auto s1 = std::to_string(i);
auto s2 = std::to_string(u);
auto s3 = std::to_string(ul);
auto s4 = std::to_string(d);
```

.N[
A big advantage compared to `sprintf` or `snprintf` is there are no more buffers
of fixed size involved that might overflow or cause truncation.
]

---
template: plain
name: stdstring_num2str
header: ##### Create `std::string` from Arithmetic Type

The following is a rewrite of a previous example using the new conversion
functions:
```
std::string tmpfilename; // fixed part followed by sequence number
…
const auto n1 = tmpfilename.find_first_of("0123456789");
assert(n1 != std::string::npos);
const auto n2 = tmpfilename.find_first_not_of("0123456789", n1+1);
std::size_t nx;
const auto num = std::stou(tmpfilename.substr(n1, n2), &nx);
assert(nx == n2-n1);
tmpfilename = tmpfilename.substr(0, n1)
            + std::to_string(num+1)
            + tmpfilename.substr(n2);
```

---
template: plain
link_to: boost_lexical_cast
name: boost_lexical_cast
header: ## Boost: Lexical Cast

[Boost.Lexical_cast]: http://www.boost.org/doc/libs/release/doc/html/boost_lexical_cast.html

With [Boost.Lexical_cast] there is a particular elegant solution for converting
between `std::string`-s and numeric types, spelled `lexical_cast`.._[]

* Internally `std::stringstream`-s are used, so it can convert

  * **from** every class or basic type that defines and implements `operator<<`
    as stream insertion,

  * **to** every class or basic type that defines and implements `operator>>` as
    stream extraction.

The basic usage form looks like this (with `std::string s` and `double d`):
```
   s = boost::lexical_cast<std::string>(d);
   d = boost::lexical_cast<double>(s);
```

.F[:
Still better: `boost::lexical_cast`s are not limited to conversions which – at
one end – have an `std::string` involved, but are capable to cross-convert
between anything that adheres to the requirements summarized above.
]

---
template: withinfo
graphic: StringBasics
section: Input and Output
name: stdstring_io
header: #### Input and Output

Output of character strings is usually done with an overload of `operator<<`,
sometime even called "output operator":._[]
```
std::string greet{"hello, world"};
…
std::cout << greet;
```

.N[
Note that the result for strings containing embedded `'\0'` characters might not
be what is expected (depending on the expectation :-)).
]

.F[:
Of course, this is not a specific operator for output but an overload to the
left-shift operator (as introduced in C), when the left-hand operand is an
output stream. Nevertheless, especially when C is used outside the realm of
embedded programming, some call `operator<<` now *output operator*.
]

---
template: withinfo
graphic: StringBasics
section: Input and Output
name: stdstring_in_word
header: ##### Reading with `operator>>`

[White Space]: http://de.wikipedia.org/wiki/Leerraum

The overloaded `operator>>` for `std::string`-s reads words by word:
```
std::string word;
while (std::cin >> word) …
```

Words are separated by arbitrary [White Space], usually (at least) the
characters for:

* Line Feed (`'\n'`)
* Space (`' '`), and
* horizontal / vertical Tabulators (`'\t'` and `'\v'`).

.N[
When reading `std::string`-s with `operator>>` usually no empty lines can be
recognized, as any line feed characters are silently skipped as white space.
]

---
template: withinfo
graphic: StringBasics
section: Input and Output
name: stdstring_in_word
header: ##### Reading with `std::getline`

Input into `std::string` can also be read by line …
```
std::string line;
… std::getline(std::cin, line) …
```

… or upto an arbitrary delimiter character:
```
std::string field;
… std::getline(std::cin, field, ':') …
```

.N[
Flexibility of the above is limited as **exactly one** delimiter character may
be specified.
]

It is not possible to specify a set of alternative delimiters – e.g. full
stop, comma, and semicolon.._[]

.F[:
While a small helper function accepting a set of delimiters shouldn't be that
hard to write, this kind and much more sophisticated parsing of input patterns
is possible with [Regular Expressions]. After having been available through
[Boost.Regex] for a long time – regular expressions became part of the C++11
standard library (see http://en.cppreference.com/w/cpp/regex/basic_regex).
]

[Boost.Regex]: http://www.boost.org/doc/libs/release/libs/regex/doc/html/index.html
[Regular Expressions]: http://en.wikipedia.org/wiki/Regular_expression

---
template: plain
name: cpp11_regular_expressions
header: ### C++11: Regular Expressions

With the adoption of regular expressions in C++11 a powerful library component
was made available for:

* Comparing character strings

* Extracting parts from character strings
 
* Modifying character strings

.N[
Developers experienced with regular expressions usually tend to do nearly every
string processing by means of regular expressions.
]

Compared to an equivalent algorithm using low-level string processing
functionality, regular expressions typically

* have much more compact source,

* therefore are better comprehensible and

* hence easier to modify and extend.


---
template: plain
name: cpplib_regex_defects
header: #### Linux `<regex>` defects warning

.W[
For more than a year after major Linux variants had begun the transition to the
C++11 library implementation, the header file `<regex>` was contained with the
actual implementation code to 99% broken.
]

The effect was that a program with regular expression processing compiled but

* either exposed exceptions at run-time (due to the missing parts in the
  implementation)

* or simply did not do what was expected.

.N[
Luckily the regular expressions component from Boost could – *and still can* –
be used as compatible replacement.._[]
]

.F[:
The difference expresses itself typically only in which header file is included
and from which namespace global names are taken, `std::` or `boost::`.
]

---
template: plain
name: regex_examples
header: #### Regular Expressions by Example

A short introduction to regular expressions is best given by example.

To try such examples, a simple small main program is fully sufficient:._[]
```
#include <iostream>
#include <regex>
#include <string>

int main() {
    using namespace std;
    const string rs{"… (regular expression to try) …"};
    regex rx{rs};
    string line;
    while (getline(std::cin, line)) {
        if (regex_match(line, rx))
            cout << "input matched: " << rs << endl;
        else
            cout << "failed to match: " << rs << endl;
    }
}
```

.F[:
Of course, for any new regular expression to try, the program needs to be
recompiled. To avoid this the program could be rewritten to take the regular
expression (string) from a command line argument.
]

---
template: plain
name: regex_example_intnum
header: ##### Regex Example: Integral Numbers

[Raw String Literal]: http://en.cppreference.com/w/cpp/language/string_literal

Recognizing integral numbers with regular expressions is very easy:

* `[0-9]+` says that there should be a digit, optionally repeated but at least
  one.

* `\d+` is basically the same.

* `-?\d+` allows for an optional sign prefixed to the number.

.W[
As a backslash is often part of regular expressions, it must not be forgotten to
quote it (by duplication) if the expression is specified as classic literal.
]

Classic literal:
```
const std::string rs{"-?\\d"};
```

As a [Raw String Literal] as introduced with C++11:
```
const std::string rs{R"(-?\d)"};
```

---
template: plain
name: regex_example_floatnum
header: ##### Regex Example: Integral Numbers

The following regular expressions describe floating point numbers, starting out
simple and adding feature by feature:

.N[
The dot cannot be used directly below and needs to be quoted, as it would
represent "any character" otherwise.._[]
]

* `\d+[.]\d+` just two dot-separated parts

* `\d*[.]\d+|\d+[.]\d*` digits either before or after the dot optional

* `[-+]?(\d*[.]\d+|\d+[.]\d*)` left hand optional plus or minus sign …

* `[-+]?(\d*[.]\d+|\d+[.]\d*)([eE][-+]?\d+)?` … optional exponent …

* `[-+]?((\d*[.]\d+|\d+[.]\d*)|(\d+[.]?\d*[eE][-+]?\d+))`  
   dot optional if there is an exponent

.F[:
Readers already familiar with regular expressions may ask why the dot wasn't
quoted with a backslash like in: `\d+(\.\d+){3}`. Of course this would have
worked too but the author of this text prefers to quote the dot with a *single
character* character class for better readability.
]

---
template: plain
name: regex_commenting
header: ##### Side Note: Commenting Regular Expressions

Experience tells that simple regular expressions are easily comprehensible
after a little training and practicing. With rising complexity explaining the
regular expression structure in comments should be considered:
```
… R"([-+]?((\d+[.]\d*|\d*[.]\d+)|(\d+[.]?\d*[eE][-+]?\d+)))" …
//  :|   |^|~~~~~~| ||| |~~~~~~|^|~~~|     |~~~~|  ||~~~|^:
//  :|   |^|      | ||| |      |^|| ||     || sign ^|   |^:
//  :|   |^|right ^^^|| |      |^|| ||     ||  optional |^:
//  :|   |^|... or --^| |      |^|| ||     |^-exponent-^|^:
//  :|   |^|... left -^^^      |^|| |^^^^^^^-- opt. and |^:
//  :|   |||... opt. digits    |||^^^- mandatory digits ||:
//  :|   ||\___ no exponent ___/|\___ with exponent ____/|:
//  :|   |+----<< alternative major components >>--------+:
//  :^^^^^-- optional sign                                :
//  :.............. raw string delimiters ................:
// underlining marks mandatory parts of each major component
// ~~~~~~~~~~~       ~~~~~~~~~ ~~~~~
```

.N[
If it gets even more complicated than this a large regular expression might be
split into parts which are then explained separately.
]

---
template: plain
name: regex_examples
header: ##### Regex Example: IP numbers

An IP number consists of for integral parts separated by dots:

* `\d+[.]\d+[.]\d+[.]\d+` – the straight forward approach

* `\d+([.]\d+){3}` – same with using repetition

Note that the parentheses in the second example will apply the repetition
count `{3}` to the whole parenthesized sequence `[.]\d+`.

* Without (necessary) parentheses the meaning would be different:  
  `\d+[.]\d{3}` is a digit sequence of any length, followed by a dot, followed
  by exactly three more digits.

* On the other hand, parentheses that do not change precedence may be used
  for more clarity,._[]

  *  e.g. `(\d+{1,3})(([.]\d+){1,3}){3}`

  * similar to `(a*b) + (c/d)` in an arithmetic expression.

.F[:
Or rather *in the hope for more clarity*, as too many parentheses also reduce
readability … (but may help to skip over related parts with a parentheses
matching editor).
]

---
template: plain
name: regex_examples_parentheses
header: ##### Side Note: More on Parentheses

The parentheses were used in the last examples to changed precedence of regular
expression operators, which are from highest to lowest:._[]

* optionality and repetition (`?`, `+`, `*`, `{…}`, `{…,…}`)

* concatenation ("invisible" operator)

* alternative (`|`)

.F[:
There are a few more like anchoring at the beginning (`^`) or at the end (`$`)
for which special rules apply as there use is limited to certain places.
]

When extracting parts of a string controlled by regular expressions, parentheses
may also determine the (sub-) sequences of interest.

.N[
There are also purely grouping parentheses, written as `(:?` and `)`. But as
their use tends to make regular expressions slightly less readable they were
avoided in the introductory examples.
]

---
template: plain
name: regex_examples_grouping
header: ##### The Trick to Do Group Separators

[String Literal Concatenation]: http://en.wikipedia.org/wiki/C_syntax#String_literal_concatenation

Frequently numbers are written by separating digits into groups:

* Currencies often group digits by three, except for the fractional part, which
  typically has exactly two digits (or may be omitted).

* The German way to write telephone numbers (according to the DIN) is to build
  groups of two digits from the right, separated by blanks.._F[]

```
std::regex euro_currency("[1-9]\\d{,2}([.]\\d{3})*(,\\d{2})?");
// first up to three .....|^^^^^^^^^^||         | |        |
// (opt. repeated) groups of three ...|^^^^^^^^^| |        |
// finally (opt.) cents ..........................|^^^^^^^^|

std::regex din_telephone(
//|------- optional -------------------------|
//|        including ONE trailing blank ---| |
//|   v--- surrounded by parentheses ----v V | 
 "(?:[(]" "(0|0[1-9])(?: [0-9][0-9])*" "[)] )?" // <-- area code
         "[1-9][0-9]?(?: [0-9][0-9])*"          // <-- local line
);
```

.F[:
That second part of the example uses [String Literal Concatenation] (introduced
with C89 but maybe a lesser known feature of the C++ language) and makes the
regex c'tor argument more stand-out.
]

---
template: plain
name: regex_examples_whitespace
header: ##### The Trick to Do White Space Sequences

Space characters in regular expressions represent themselves,._[] i.e. they
must match exactly the *same amount and kind* of white space.

Regular expressions may be easily bloated with `\s+` or `[ \t]*` if they are
used to match text in which

* sequences of blanks or even any white space (including tab etc.) can be used
  with the same meaning as a single blank, or

* white space may optionally be interspersed at many locations.

.N[
A good solution is to run a [normalization step](#regex_examples_subst) on
a string before checking it against a regular expression:

1. Remove all **optional** white space (and sequences thereof).
2. Where white space is **mandatory** turn sequences of any kind of white space
   into exactly one single blank.
]

.F[:
Some variants of regular expressions allow to take away any meaning from white
space embedded in a regular expression, so that it may be used for structuring.
Where a space characters has to occur literally, `\s` can be used (and `\t` for
tabs etc.).
]

---
template: plain
name: regex_examples_notperfect
header: ##### The Trick NOT Trying It Too Perfect

You might feel tempted to use sequence counts for direct control of digit
sequences, like in the IP number example each components can have no more than
three digits:

* `\d+{1,3}([.]\d{1,3}){3}` allows at most three digits in each part

But this is of course not sufficient to exclude any invalid input, as the
numeric values between dots must not exceed 255. Which problems arise when
overdoing range checks are easily demonstrated in the simple example to
recognize a month in a date as a number between 1 and 12:

* `1[0-2]|[1-9]` for 1, 2, 3 … 12 like in English dates (8/12/2014)

* `1[0-2]|0[1-9]` for 01, 02, … 12 like in ISO dates (2014-08-12)

So anything._[] is possible at the cost of readability … but:

.N[
Often the better approach is to allow any number (maybe with checking for an
upper limit of contained digits) and to postpone more validity tests until
the numeric value is picked up from the string.
]

---
template: plain
name: regex_examples_access
header: ##### Accessing Sub-Patterns

Once some text matches a given regular expression, it is very easy to access
sub-patterns.

At first parentheses need to be placed in the regular expression to mark the
sub-patterns of interest:
```
// start c'tor -+       v-----------------------------v
//   arg. list  |       | 1st sub-pattern selection   |
std::regex telno{"(?:[(]((0[1-9]?(?: [0-9][0-9])*)[)] )?"
                      "([1-9][0-9]?(?: [0-9][0-9])*)"};
                  //   | 2nd sub-pattern selection | |   end c'tor
                  //   ^---------------------------^ +-- arg. list
```

Then `std::regex_match` is called with an additional argument:
```
std::string input;
while (std::getline(std::cin, input)) {
    std::smatch select;
    if (std::regex_match(input, select, telno))
        std::cout << "area code:  " << select[1] << '\n'
                  << "local line: " << select[2] << '\n';
}
```

---
template: plain
name: regex_examples_access
header: ##### Matching vs. Searching

If in an regular expression there is only a single sub-pattern of interest
instead of `std::regex_match` using `std::regex_find` should be considered:

Assuming an `std::string input` the following
```
std::regex eur_amount("EUR \\d+,\\d{2}");
if (std::regex_search(input, smatch, eur_amount)) …
   … smatch[0] … // access whole match
```

is equivalent to:
```
std::regex eur_amount(".*?(EUR \\d+,\\d{2}).*");
if (std::regex_match(input, smatch, eur_amount)) …
   … smatch[1] … // access first (and only) sub-match
```

.N[
Here the *non-greedy* variant `*?` of the plain repetition operator `*` has been
used, though it only makes a difference if in `input` there are two possible
matches starting with "EUR" each._[]
]

.F[:
Getting accustomed to take care helps to avoid subtle problems like that of
`".*(\\d+).*"` which often come to surprise of regular expression newbies …
]

---
template: plain
name: regex_examples_subst
header: ##### Doing Substitutions

Regular expressions can also be used to describe what should be substituted
inside a string:._[]
```
std::string s;
… // read an input line into s

// remove leading and trailing white space:
s = std::regex_replace(s, std::regex("^[ \t]+"), ""); 
s = std::regex_replace(s, std::regex("[ \t]+$"), ""); 
// normalize remaining white space to a single blank:
s = std::regex_replace(s, std::regex("[ \t]+"), " "); 
```

The use of `^…` and `…$` in the regular expressions above will *anchor the
patterns* to match only at the beginning or the end respectively.

.N[
Preprocessing to [normalize input](#regex_examples_whitespace) in which white
space sequences are optionally allowed at many places can help to simplify regular
expressions used later for input analysis.
]

.F[:
It is **not** an oversight to use `\t`, not `\\t` despite the classic form of
string literal, as the former gets translated to a tab character which is then
taken literally in the regular expression.
]

---
template: plain
name: regex_examples_subst_reuse
header: ##### Reusing Sub-Matches in Substitutions

[ECMA-Script]: http:://ecma-international.org/ecma-262/5.1/#sec-15.5.4.1
[POSIX Rules]: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/sed.html#tag_20_116_13_03

Substitutions controlled by regular expression become even more powerful as
sub-matches can easily be reused in substitutions.

The following code swaps

* currency names (first sub-pattern matched by `EUR|DKK|GBP|SEK|NOK`)

* with amounts (second sub-pattern matched by `\d+,\d{2}`):._[]
```
std::regex eur_amount("(EUR|DKK|GBP|SEK|NOK) (\\d+,\\d{2})");
…
std::regsub(input, eur_amount, "$2 $1");
```

.F[:
Using double backslashes in the regular expression specification is necessary
because it is specified here as classic C string literal.
]

.N[
The default syntax to refer to matched text is that of [ECMA-Script].
]

Alternatively [POSIX Rules] can be enabled with the flag
`std::regex_constants::format_sed` as fourth argument.

---
template: plain
name: boost_regular_expressions
header: ### Boost: Regular Expressions

[Boost.Regex]: http://www.boost.org/doc/libs/release/libs/regex/doc/html/index.html
[Boost.String_algo]: http://www.boost.org/doc/libs/release/doc/html/string_algo.html

C++11 regular expressions emerged from [Boost.Regex].

Therefore there is little difference:

* Some options and features available from Boost have not been standardized.

* Moreover, Boost regular expression._[] may evolve more rapidly with respect
  of new, experimental features or dialects supported.

.N[
Unless you have a [broken implementation](#cpplib_regex_defects) of regular
expressions the standard implementation is usually sufficient and there is
little need to use Boost regular expressions.
]

.F[:
To avoid ambiguity it should be noted that Boost actually supplies two variants
of regular expressions: The full-blown implementation available as a separate
component (to which this page refers), and a separate, much stripped down
implementation bundled with [Boost.String_algo], the extended string algorithms.
]

---
template: plain
link_to: xpressive/user_s_guide
name: boost_xpressive
header: ### Boost: Xpressive

[Boost.Xpressive]: http://www.boost.org/doc/libs/release/doc/html/xpressive.html

Processing regular expressions is usually broken into two parts:

* Constructing a state machine (FSM) from what is textually specified.

* Executing that FSM guided by an actual string to compare to an regular
  expression, access parts, etc.

.N[
The separation makes sense because the first part is typically more time
consuming but will need to happen only once, while the second may happen
frequently but executes fast.
]

With C++11 and Boost both parts usually take place at runtime.._[]

.F[:
Of course, any program using regular expressions should be structured to exploit
this separation, shifting the FSM construction out of the loops that actually
match against or otherwise process strings with the regular expression
machinery.
]

[Boost.Xpressive] implements regular expressions with Meta Programming techniques,
effectively shifting the first part from runtime to compile-time.

---
template: plain
link_to: xpressive/user_s_guide
name: boost_xpressive
header: ### Boost: More String Operations

[Boost.String_algo]: http://www.boost.org/doc/libs/release/doc/html/string_algo.html
[Boost.Tokenizer]: http://www.boost.org/doc/libs/release/libs/tokenizer/index.html

Two more libraries of Boost which specifically deal with string processing are

* [Boost.String_algo] and

* [Boost.Tokenizer].

The first provides many string processing functions that some might feel
"missing" in the standard libraries, the second provides (relatively) easy
but nevertheless flexible mechanisms to "chop" a longer string into parts.

---
template: plain
name: std_iostreams_more_boost
header: ## I/O-Streams

---------------------------------------------------------------------------

* [Basic Overview				](#iostream_basics)
* [Using and Overloading I/O-Operations		](#io_op_use_and_overload)
* [C-Style Formatting				](#boost_format)
* [Extending the Back-End			](#boost_iostreams)
* [Serialising Object Networks			](#boost_serialisation)

---------------------------------------------------------------------------

---
template: linkinfo
graphic: IOStreamBasics
name: iostream_basics
header: ### Library-Basics – I/O-Streams

-------------------------------------------------------------------------------

* [Front-End and … 	](#iostream_frontend)
* [… Back-End 		](#iostream_backend)

-------------------------------------------------------------------------------

* [I/O-State (Bits) 	](#iostream_statebits)

-------------------------------------------------------------------------------

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: iostream_frontend
header: #### I/O-Stream Front-End

The I/O-Stream Front-End consists of

* the base class `std::ios`._[] with some common defintions

* derived from it classes `std::istream` und `std::ostream` which are typically
  used as reference arguments to parametrise I/O-streams for functions called,

* and the following classes meant to be instantiated:

  * `std::ifstream`, `std::ofstream`, and `std::fstream` (File-Streams)
  * `std::istringstream`, `std::ostringstream`, and `std::stringstream`
     (String-Streams).

.F[:
As with `std::string` the architecture is even more generic and the "classes"
above are rather `typedef`-s for more generic template classes, which are
parametrized not only in a character type but also in some other respects. This
fact need not be made prominently visible if the focus is on explaining the
relationship between the classes participating in the design – as it is the
case here.
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: io_streams
header: ##### Common Interface

Operations for stream input and output are partially implemented as member
functions of classes `std::istream` and `std::ostream`, partially as free
standing functions.

.N[
More overloads of `operator>>` and `operator<<` may be added to support user
defined data types.
]

Such overloads can only have the form of free functions (as otherwise new
member functions would have to be added to `std::istream` and `std::ostream`).

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_ios
http://en.cppreference.com/w/cpp/io/basic_istream
http://en.cppreference.com/w/cpp/io/basic_ostream
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: io_filestreams
header: ##### File Streams

The various file stream classes are used depending on the I/O direction:

* `std::ifstream` for reading
* `std::ofstream` for writing
* `std::fstream` for reading and writing._[]

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_fstream
http://en.cppreference.com/w/cpp/io/basic_ifstream
http://en.cppreference.com/w/cpp/io/basic_ofstream
]

.F[:
Note that in this case read and write positions in the stream are independent of
each other and – depending on the task at hand – may or may not need explicit
synchronisation.
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-System Front-End
name: io_stringstreams
header: ##### String Streams

The various file stream classes are used depending on the I/O direction:

* `std::istringstream` for reading
* `std::ostringstream` for writing
* `std::stringstream` for reading and writing._[]

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_stringstream
http://en.cppreference.com/w/cpp/io/basic_istringstream
http://en.cppreference.com/w/cpp/io/basic_ostringstream
]

.F[:
Note that in this case read and write positions in the stream are independent of
each other and – depending on the task at hand – may or may not need explicit
synchronisation.
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Streams Back-End
name: iostream_backend
header: #### I/O-Stream Back-End

The main responsibility of the I/O-Stream back-end is abstraction and buffering
(in case file streams).

Buffering allows to

* transmit data between internal memory and external storage in optimised block
  sizes,

* while the application has any freedom in which portions data is consumed or
  produced.

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_streambuf
http://en.cppreference.com/w/cpp/io/basic_filebuf
http://en.cppreference.com/w/cpp/io/basic_stringbuf
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Stream State-Bits
name: iostream_statebits
header: #### I/O-Stream State Bits

Each stream has a number of state bits.

* If all are clear, the stream is said to be in *GOOD*-state.

* If during input of a given data type **before any valid character** an
  * *unexpected* character occurs, the stream assumes the *FAIL* state by
    setting `ios::std::failbit`;._[]
  * there are *no more characters* to be read, the stream
    * either assumes the *EOF* state by setting `ios::std::eofbit` (if there
      are no more characters available);
    * or assumes the *BAD* state by setting `ios::std::failbit` (if further
      reading makes no sense because of some kind of hardware error);
* otherwise (if some valid character(s) have already been extracted)
  * further processing of characters will be stopped
  * but the stream will stay in the *GOOD* state.

.F[:
The unexpected character will stay available for later processing, but the
state bits must first be reset by `clear()`.
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Streams State-Bits
name: iostream_statebits
header: ##### State-Dependent I/O-Stream Behaviour

As soon as an I/O-stream leaves the *good*-state further operations with that
stream are ignored **except for `clear()` and `close()`**.

This has especially to be considered for a more detailed analysis of input:

* Any state change leaves the current position in the stream **prior to** the
  character causing the problem.
* Input not adhering to the expected format._[] – e.g. if a letter occurs where
  a digit is expected – input is processed **up to but not including** the
  unexpected character.

To skip over (at least) this character,

* **first** the stream must be put in the *good*-state, only
* **then** an operation like `ignore` will work.

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_ios/clear
http://en.cppreference.com/w/cpp/io/basic_istream/ignore
]

.F[:
Usually determined by the data type to be read with `operator>>`.
]

---
template: withinfo
graphic: IOStreamBasics
section: I/O-Streams State-Bits
name: iostream_statebits
header: ##### Exceptions on State Change

Individually for each stream and state it can be chosen that an exception is
thrown for any

* **change to** that state (i.e. setting the corresponding state bit) and
* attempted operation **while in** that state.

```
// Excerpt from a hypothetical "forever running" TCP-Client
std::ifstream from_server;
… // establish connection through TCP/IP-Socket
from_server.exceptions(std::ios::badbit
                     | std::ios::eofbit
                     | std::ios::failbit);
try {
    for (;;) {
        std::string command_string;
        std::getline(from_server, command_string);
        … // process command_string
    } /*notreached*/
}
catch (std::ios_base::failure &e) {
    … // socket connection closed and/or data transfer failed
}
```

---
template: plain
name: io_op_use_and_overload
header: ### Using and Overloading-I/O Operations

The builtin "left shift" and "right shift" operators are conventionally
overloaded for

* reading "textual input" to be converted to some internal representation, and

* converting some internal representation to "formatted output".

.N[
To emphasize the difference between the original meaning and its use for I/O,
`operator<<` is also called [Stream Extraction](#io_stream_extraction) and
respectively operator>>` [Stream Insertion](#io_stream_insertion).
]

---
template: plain
name: io_stream_extraction
header: #### Stream Extraction

The following pages concentrate on [Formatted Input](#input_extraction_rules)
consumed with `operator>>`.

.N[
Note that there are other ways to "extract" input from a stream.
]

* For single characters:
  * `int get()`
     * character read or `EOF` received as return value
  * `bool get(char &ch)`
     * character read received via reference argument
     * return indicates success of end-of-file
* For character sequences:
  * some variants of `read` (member function) and
  * `getline` (member function / gobal function)

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_istream/get
http://en.cppreference.com/w/cpp/io/basic_istream/read
http://en.cppreference.com/w/cpp/io/basic_istream/getline
http://en.cppreference.com/w/cpp/string/basic_string/getline
]

---
template: plain
name: input_extraction_rules
header: ##### Formatted Input Rules

The general rule is:

* As many characters in the input sequence are consumed
  * as can be interpreted as textual representation of the type
    to be read
  * and the stream stays in *GOOD* state.
* If there as not even one such character, the stream goes
  * into *EOF* state if no more characters follow;
  * into *FAIL* state if invalid characters follow.

.I[
For more information see:
http://en.cppreference.com/w/cpp/concept/FormattedInputFunction
]

---
template: plain
name: formatted_input_example
header: ##### Formatted Input Example

The following extracs floating point values from standard input:

.pull-left[
```
#include <iostream>
int main() {
    auto sum = 0.0;
    auto count = 0L;
    double value;
    while (std::cin >> value) {
        sum += value;
        count += 1;
    }
    … // shown later
}
```
Possible input:
```
50.0    25.5 25.
   100 1e+2 -.5
```
]
.pull-right[
(For the part omitted at the end see
[Formatted Output Example](#formatted_output_example).)

The input may consist of an any number of floating point values separated by any
amount and any kind of white space.

Furthermore, as long as execution takes place in the **"C" Locale**, every
number format is accepted that is also valid for a floating point literal in
C++ source code.._[]

Finally note that besides "End-Of-File" but also **any invalid input** will
cause the while loop to end.
]

.F[:
Though **not** including the usual suffixes `f`, `F`, `L`, and `l` (to choose
`float` or `long double` over `double`.
]

---
template: plain
name: input_extraction_overloading
header: ##### Input Extraction Overloading

To extract `MyClass`-objects from a stream of `char`:._[]
```
std::istream&
operator(std::istream& lhs, MyClass& rhs) {
    …
    … // whatever needs to be done
    …
    return lhs;
}
```

**Using of a reference for the argument `rhs` is mandatory.**

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt
http://en.cppreference.com/w/cpp/io/basic_istream/operator_gtgt2
]

.F[:
By using a template this can be generalized for streams based on any
character-type.
]

---
template: plain
name: io_stream_insertion
header: #### Stream Insertion

The following pages concentrate on *formatted output* generated with `operator<<`.

.N[
Note that there are other ways to "insert" output into a stream.
]

* For single characters:
  * `put` (member function)
* For character sequences:
  * `write` (member function)

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_istream/put
http://en.cppreference.com/w/cpp/io/basic_istream/write
]

---
template: plain
name: output_insertion_rules
header: ##### Formatted Output Rules

* As many characters in the input sequence are consumed
  * as can be interpreted as textual representation of the type
    to be read
  * and the stream stays in *GOOD* state.
* If there as not even one such character, the stream goes
  * into *EOF* state if no more characters follow;
  * into *FAIL* state if invalid characters follow.

.I[
For more information see:
http://en.cppreference.com/w/cpp/concept/FormattedOutputFunction
]

---
template: plain
name: formatted_output_example
header: ##### Formatted Output Example

```
#include <iostream>
#include <iomanip>
int main() {
   … // shown earlier
   std::cout.setf(std::ios::fixed);
   std::cout.precission(4);
   std::cout << "Average:"
   std::cout << std::setw(10) << sum/count;
   std::cout << std::endl;
}

```
(For the part omitted at the begin see
[Formatted Input Example](#formatted_input_example).)

.pull-left[
Possible output:
```
Average:   16.6667
```
]
.pull-right[
The numeric value will always have **fixpoint** format showing
**4 decimal** places, right-justified in a **10 character wide** printing
zone.._[] (If it does not fit within that width the printing zone will be
automatically extended.)
]

.F[:
Compared to C-style `printf` format strings this looks like a rather clumsy way
of expressing that …
]

---
template: plain
name: output_insertion_overloading
header: ##### Overloading "Stream Insertion"

To insert `MyClass`-objects into a stream of `char`:._[]
```
std::ostream&
operator<<(std::ostream& lhs, const MyClass& rhs) {
    …
    … // whatever needs to be done
    …
    return lhs;
}
```

Using a value argument for `rhs` might give a small advantage if `MyClass`
is tiny **and copyable**.
]

.I[
For more information see:
http://en.cppreference.com/w/cpp/io/basic_ostream/operator_ltlt
]

.F[:
Of course, by using a template the above can be generalized to work on
streams based on any character-type.
]
---
template: plain
name: random_numbers
header: ## Random Numbers

---------------------------------------------------------------------------

* [Random  Numbers Library		](#cpp11_random)
* [Generating Values			](#cpp11_random_generators)
* [Specifying Distributions		](#cpp11_random_distributions)

---------------------------------------------------------------------------

---
template: plain
name: cpp11_random
header: ## C++11: Random

Compared to C style pseudo random number generation with `std::rand`, C++11 has
adopted a facility for generating random numbers with given distributions, but
at a price:

The code to role a simple dice isn't any more as easy._[] as
```
int throw_dice() { return 1 + std::rand() % 6; }
```

but requires at least something along the following lines:
```
int throw_dice() {
    static std::random_device rd;
    static std::mt19937 gen(rd());
    static std::uniform_int_distribution<> dis(1, 6);
    return dis(gen);
}
```

.F[:
… and wrong or at least flawed for the following reasons: (1) Some C
implementations start to repeat the "random" sequence as early as after 65534
repetitions and (2) if the range of pseudo-random numbers (starting with zero)
is not evenly divisible by six the chosen way to map the numbers to 1..6 will
slightly favour the lower values.
]

---
template: plain
name: cpp11_random_generators
header: ### C++11: Random Number Generators

.N[
All random number engines generate the next value by applying the function call
operator (without arguments).._[]
]

Some random number generators may be used without distributions if a uniform
distribution over the range of generated values is required, e.g.:

* `std::mt19937` – uniformly distributed values over a 32 bit range
* `std::mt19937_64` – uniformly distributed values over a 64 bit range

The C++11 standard also defines an `std::random_device` which may either be
mapped to a non-deterministic random source or (if not available) to one of
the existing (pseudo-random) sources.

.I[
For more informations on the available random number generators see subsection
[Random Number Engines] in:
http://en.cppreference.com/w/cpp/numeric/random
]
[Random Number Engines]: http://en.cppreference.com/w/cpp/numeric/random#Random_number_engines

.F[:
The prefix `mt` abbreviates the algorithm ([Mersenne Twister]) and `19937` is
the period, after which the generated numbers start to repeat identically: which
is 2<sup>19937</sup>. Or in other words: if such a generator existed since the
big bang and random numbers were extracted with a GHz clock since, until today
it would have generated only numbers from a tiny weeny fraction of its
non-repeating range.
]

[Mersenne Twister]: http://en.wikipedia.org/wiki/Mersenne_Twister

---
template: plain
name: cpp11_random_distributions
header: ### C++11: Random Number Distributions

.N[
All distributions produce the next value by applying the function call operator
with a generator (engine) as parameter.
]

There are many distributions available – separately from the generator – of
which the *Uniform Distribution* is probably the one most often used. It is
available as:._[]

* `std::uniform_int_distribution`  
  generating integral values in a given range
* `std::uniform_real_distribution`  
  generating floating point values in a given range 
* `uniform_canonical`  
  generating values between 0..1 with a given precision

.I[
For more information on the above and other distributions see subsection
[Random Number Distributions] in:
http://en.cppreference.com/w/cpp/numeric/random
]

[Random Number Distributions]: http://en.cppreference.com/w/cpp/numeric/random#Random_number_distributions

.F[:
Note that contrary to the otherwise asymmetric limits, as commonly used in C and
the C++-STL, the limits specified for distributions are inclusive and symmetric.
]

---
template: plain
name: boost_random
header: ### Boost: Random

[Boost.Random]: http://www.boost.org/doc/libs/release/doc/html/chrono.html

[Boost.Random] implements the C++11 conformant [Random classes](#cpp11_random)
with some additions. 


---
template: plain
name: cpp11_chrono)
header: ## Durations and Clocks

---------------------------------------------------------------------------

* [C++11 Chrono Overview			](#cpp11_chrono)
* [Durations and …				](#chrono_duration)
* [… Time Points (Clocks)			](#chrono_clock)

---------------------------------------------------------------------------

---
template: plain
name: cpp11_chrono
header: ### C++11: Chrono

With C++11 a library component for managing date and time was introduced
(beyond what was available for long because of C compatibility).

* As many similar libraries it makes a clear distinction between

  * durations and

  * time points.

The feature that makes this library shine is its flexibility with respect to
the usual trade-off between resolution, range, and space requirements of the
underlying type (to store a duration or time point).

.I[
The chapter on the C++11 *Chrono Library Part* from Nicolay Josuttis Books,
referenced above, has also been made available online here:
http://www.informit.com/articles/article.aspx?p=1881386&seqNum=2
]


---
template: plain
name: chrono_duration
header: ### `std::chrono` – Durations

Though the duration type is fully configurable through a template._[], most
programs will probably choose from one of the predefined types that satisfies
their needs for resolution:

* `std::chrono::nanoseconds` at least 64 bit signed
* `std::chrono::microseconds` at least 55 bit signed
* `std::chrono::milliseconds` at least 45 bit signed
* `std::chrono::seconds` at least 35 bit signed
* `std::chrono::minutes` at least 29 bit signed
* `std::chrono::hours` at least 23 bit signed

.N[
Duration type conversions to a *finer grained* type will always happen
automatically, while conversions to *coarser grained* type require an
`std::chrono::duration_cast`.
]

A 64-bit type the minimum requirement for nanosecond resolution – with the
**minimum requirement** for the other types adapted accordingly – the minimum
range of a duration covers ±500 years.

.F[:
E.g. a duration type could well count in 5/17 microseconds if that matches the
resolution of a hardware timer exactly and allows for precise calculations
without any rounding errors or occasional jitter.
]

---
template: plain
header: #### Duration Example (1)

For a basic use it needs only to be understood that automatic conversion
happen as long as the target duration counts in finer grained units …
```
#include <chrono>
…
std::chrono::minutes m{22};  // m.count() is 22
std::chrono::seconds s{17};  // s.count() is 17
s += m;                      // s.count() is 1337 (22*60 + 17)
s *= 100;                    // s.count() is 133700
```

… while assignments to coarser grained durations are an error …
```
m = s;                       // does NOT compile
```
… unless an `std::chrono::duration_cast` is applied:._[]
```
m = std::chrono::duration_cast<std::chrono::minutes>(s);
                             // m.count() is 2228
```

---
template: plain
header: #### Duration Example (2)

To avoid long namespace prefixes, namespace aliases are handy:._[]
```
namespace sc = std::chrono;   // abbreviating std::chrono:: to sc::
…                                  // continuing from previous page
sc::hours h = sc::duration_cast<sc::hours>(m); // m.count() is 2228
//   auto h = sc::duration_cast<sc::hours>(m);
```

Finally a useful helper to turn durations into something readable:
```
std::string to_string(sc::seconds sec) {
    const auto h = sc::duration_cast<sc::hours>(sec);
    const auto m = sc::duration_cast<sc::minutes>(sec-h);
    const auto s = sc::duration_cast<sc::seconds>(sec-h-m);
    return std::to_string(h.count()) + "h"
         + std::to_string(m.count()) + "m"
         + std::to_string(s.count()) + "s";
}
…             // continuing from above
… to_string(s) … // returns "37h8m20s"
```

.F[:
These seems especially useful to abbreviate nested `std::` namespaces – like
those from the `<chrono>` – while keeping a gentle reminder the identifier
following is from the standard library.
]

---
template: plain
name: chrono_clock
header: ### `std::chrono` – Clocks

A duration (type) combined with an *epoch*._[] is a *clock* that represents
a time point.

Which kind of clocks are supported is basically implementation defined with the
following minimum requirements:

* `std::chrono::system_clock` – represents the usual "wall-clock" or "calendar
  date & time" of a computer system;

* `std::high_resolution_clock` – the clock with the best resolution available
  (but with a more or less frequent wrap-around);

* `std::chrono::steady_clock` – probably not tied to a specific calendar date
  and with the special guarantee that it will only advance. 

.N[
Only the last allows to reliably determine a real time span as difference of
two time points returned from its static member function `now()`.
]

.F[:
Per definition the epoch of a clock is the time point represented by the
duration zero. From its epoch a clock will reach into the past and into the
future, usually symmetrically if an ordinary signed integral or floating point
type is used.
]

---
template: plain
header: #### Clock Examples (1)

Following are the attributes of `std::chrono::system_clock` …._[]
```
resolution : 1/1000000
value range: -9223372036854775808 .. 9223372036854775807
since epoch: 45+ years
         or: 16581+ days
         or: 397964+ hours
         or: 23877893+ minutes
         or: 1432673591+ seconds
or in ticks: 1432673591377941
```

.F[:
… determined on the author's system with the helper function below:
```
  template<typename Clock>
void show_clock() {
        using period = typename Clock::period;
        using limits = std::numeric_limits<typename Clock::rep>;
        std::cout << "resolution : " << period::num << '/' << period::den << '\n';
        std::cout << "value range: " << limits::min() << " .. " << limits::max() << '\n';
        const auto tse = Clock::now().time_since_epoch();
        const auto sse = sc::duration_cast<sc::seconds>(tse).count();
        std::cout << "since epoch: " << sse /60/60/24/365 << "+ years\n";
        std::cout << "         or: " << sse /60/60/24 << "+ days\n";
        std::cout << "         or: " << sse /60/60 << "+ hours\n";
        std::cout << "         or: " << sse /60 << "+ minutes\n";
        std::cout << "         or: " << sse << "+ seconds\n";
        std::cout << "or in ticks: " << tse.count() << '\n';
}
```
]

---
template: plain
header: #### Clock Examples (2)

Clocks can also be used to determine the time passed between two time
points:._[]
```
template<typename TestCode>
void test_timing(unsigned repeat, TestCode testrun) {
    using sc = std::chrono;
    const auto started = sc::high_resolution_clock::now();
    for (auto i = 0; i < repeat; ++i) testrun();
    const auto ended = sc::high_resolution_clock::now();
    const auto delta = ended - started;
    const auto nanosec = sc:duration_cast<sc::nanoseconds>(delta);
    const auto per_run = nanosec.count() / repeat; 
    std::cout << nanosec << " ns total for " << repeat << " runs"
                            " = " << per_run << " ns per run\n";
}
…
test_timing(100*1000, // repeat 100.000 times ...
            []{
                … // ... this some code fragment
            });
```

.F[:
Note that – as far as shown here – real time is measured, not CPU time, but
`boost::chrono` has also clocks for measuring CPU time.
]

---
template: plain
name: chrono_operations
header: #### `std::chrono` – Operations

Operators are overloaded to support mixed durations and time points:

|Operand Type| Operation       |Operand Type  |Result Type    |
|:-----------|:---------------:|:-------------|:--------------|
| duration   | plus or minus   | duration     | duration      |
| time point | plus or minus   | duration     | time point    |
| time point | minus           | time point   | duration      |
| duration   | multiplied with | plain number | duration      |
| duration   | divided by      | plain number | duration      |
| duration   | modulo          | plain number | duration      |
| duration   | divided by      | duration     | plain number  |
| duration   | modulo          | duration     | duration      |

Combinations not listed in the table above result in compile time errors.

For operands with standard types._[] of different resolution the result will use
the appropriate type with the finer grained resolution.

.F[:
When non-standard types are combined the required result type will be calculated
accordingly. E.g. to store the sum of a duration counting in 10/21 seconds and
another one counting in 14/15 seconds, a result type counting in 1/105 seconds
will be used.
]

---
template: plain
name: boost_chrono
header: ### Boost: Chrono

[Boost.Chrono]: http://www.boost.org/doc/libs/release/doc/html/chrono.html

[Boost.Chrono] implements the C++11 conformant [Chrono classes](#cpp11_chrono)
with some additions. 

Such target the area of measuring CPU-time, i.e.

* clocks to which ticks only get added when the CPU is active for the current
  process,

* usually making a difference between *User Time* and *System Time*.

.I[
For more information on the option to measure CPU time with the additional
clocks provided by [Boost.Chrono] see section [Other Clocks] in
http://www.boost.org/doc/libs/release/doc/html/chrono/reference.html
]

[Other Clocks]: (http://www.boost.org/doc/libs/release/doc/html/chrono/reference.html#chrono.reference.other_clocks)

---
template: plain
name: boost_date_time
header: ## Boost: Date & Time

[Boost.Date_time]: http://www.boost.org/doc/libs/release/doc/html/date_time.html

[Boost.Date_time] has little in common with [C++11 Chrono](#cpp11_chrono),
except for maintaining a similar semantic difference between durations and time
points.

.N[
While legacy code using that library will still be around for some years, on the
long run it can be expected that the importance and user base of this library
may decrease and code be updated to use `std::chrono`.._[]
]

.F[:
Note that with [Boost.Chrono] the Chrono Library as standardized with C++11 is
now available on the Boost platform too.
]

---
template: plain
name: wednesday4
header: ## Multi-Threading

---------------------------------------------------------------------------

* [Parallelizing Independent Tasks	](#parallelizing_tasks)
* [Synchronisation with Mutexes		](#mutex_synchronisation)
* [One-Time Execution			](#onetime_execution)
* [Messaging with Condition Variables	](#condition_variables)
* [Atomic Operations			](#atomic_operations)
* [Direct Use of Threads		](#direct_use_of_threads)
* [Native Threading Model Handles	](#native_thread_handles)
* [Concurrency Recommendations		](#concurrency_recommendations)

---------------------------------------------------------------------------

With C++11 support for multi-threading was introduced.._[]

.I[
For more information on concurrency support in C++11 see:
http://en.cppreference.com/w/cpp/atomic, and
http://en.cppreference.com/w/cpp/language/memory_model
]

.F[:
At first glance concurrency features may appear "as just some
more library classes and functions". But beyond the hood, and especially in the
area of allowed optimisations and to provide [Cache Coherence] on modern
multi-core CPUs, concurrency is closely intertwined with code generation issues.
]

[Cache Coherence]: http://en.wikipedia.org/wiki/Cache_coherence

---
template: plain
name: parallelizing_tasks
header: ### Parallelizing Independent Tasks

For complex tasks that can be split into independent parts, concurrency **and
scalability to multiple cores** can be easily achieved by following a simple
recipe:

1. Separate the task into a number of different functions (or calls of the same
   function with different arguments).
2. Run each such function by handing it over to `std::async`, storing the
  `future` that is returned (easiest in an `auto`-typed variable).
3. Fetch (and combine) the results by calling the member function `get` for
   each `future`.

That way all the functions may run concurrently and the last step synchronizes
by waiting for completion.

.I[
For more information on parallelizing independent task that way see:
http://en.cppreference.com/w/cpp/thread/async
]

.F[:
Technically the return value of `std::async` is an `std::future` but as this
is a template and the type is usually somewhat different to spell out, most
usages of `std::async` store the result in an `auto`-typed variable.
]

---
template: plain
name: futures_and_promises
header: #### Foundation: Futures and Promises

The foundation on which parallelizing tasks is build are [Futures and Promises].

These need not be fully understood to apply the API (exemplified on the next
pages), but may help to understand the basic machinery:

* A future is the concrete handle which a client can use to fetch the result,
  presumably made available by a different thread of execution.

* A promise is a helper class which may be used in a separate thread to make
  a result available for a client.

.I[
For more information on promises and futures see:
http://en.cppreference.com/w/cpp/thread/future
http://en.cppreference.com/w/cpp/thread/promise
http://en.cppreference.com/w/cpp/thread/packaged_task
]

[Futures and Promises]: http://en.wikipedia.org/wiki/Futures_and_promises

---
template: plain
name: parallelizing_example
header: #### Parallelizing Example

The following example calculates the sum of the first `N` elements in `data`
by splitting the work of `std::accumulate`, into two separate function calls,
that may run concurrently:._[]
```
// calculate sum of first N values in data
//
long long sum(const int data[], std::size_t N) {
    auto lower_part_sum = std::async(
        [=]{ return std::accumulate(&data[0], &data[N/2], 0LL); }
    );
    auto upper_part_sum = std::async(
        [=]{ return std::accumulate(&data[N/2], &data[N], 0LL); }
    );
    return lower_part_sum.get()
         + upper_part_sum.get();
}
```

.F[:
Note the use of lambdas above – the actual call to `std::accumulate` will only
happen when the lambda gets executed! A similar effect can be achieved as
follows:
```
  // preparing the callable for std::async with std::bind:
… std::async(std::bind(std::accumulate, &data[0], &data[N/2], 0LL)) …
… std::async(std::bind(std::accumulate, &data[N/2], &data[N], 0LL)) …
```
]

---
template: plain
header: #### Default Launch Policy

The default behavior is that the systems decides on its own whether an
asynchronously started task is run concurrently.._[]

Using `std::async` **without an explicit launch policy**

* **is just a hint** that it is acceptable to run a callable unit of code
  concurrently,

* as long as it has finished (and possibly returned a result) latest when
  the `get`-call returns, which has bee invoked on the `std::future`.

.W[
Be sure **not** to use the default launch policy but specify concurrent
execution explicitly (see next page) whenever it is essential that two
callable run concurrently.
]

.F[:
It is a well known effect that too many parallel threads of execution may rather
degrade performance. Especially if threads are CPU bound, it makes little sense
to have more threads as cores. Therefore the standard gives considerable freedom
to the implementation, which might implement concurrency with `std::async` with
a thread pool and turn to synchronous execution or lazy evaluation at a certain
threshold.
]

---
template: plain
header: #### Explicit Launch Policies

There is a second version of `std::async` which has a first argument to specify
the launch strategy. 

The standard defines two values:

* `std::launch::async`  
  if **not set** the callable will **not** run on its own thread;._[]

* `std::launch::deferred`
  of **set** the callable will **not** be called before `get` is invoked.

.I[
For more information on launch policies see:
http://en.cppreference.com/w/cpp/thread/launch
]

.F[:
One case in which this setting this flag may make sense is to test the program
logic independent from possible problems created through race conditions or
deadlocks, originating from dependencies between the "independent tasks", that
had been overlooked.
]

---
template: plain
header: #### Catching Exceptions

If the callable started via `std::async` throws an exception, it will appear as
if it were thrown from the call to get.

Hence, if the asynchronously run task may throw, fetching the result should be
done in a try block:
```
auto task1 = std::async( … ); // whatever-is-to-do (and may throw)
auto task2 = std::async( … ); // whatelse-is-to-do (and may throw)
…
try { … task1.get() … }
} catch ( … ) { // what may be thrown from whatever-is-to-do
   … // handle the case that whatever-is-to-do threw
}
try { … task2.get() … }
} catch ( … ) { // what may be thrown from whatelse-is-to-do
   … // handle the case that whatelse-is-to-do threw
}
```

---
template: plain
header: #### Communication between Independent Tasks

First of all: If the need arises to communicate between independent tasks, this
should be taken **as a strong warning** that such tasks are actually not
independent.

.W[
If parallel tasks are not independent, further needs follow quickly with respect
to synchronize access to shared data … **with all the further intricacies following
from this**.._[]
]

Nevertheless there is one common case that requires a simple form of
communication between otherwise independent tasks.

.N[

* If there are several tasks working towards a common goal
* of which one fails, making the goal unattainable,
* the others should not waste CPU-time needlessly.

]

.F[:
In other words: Pandora's proverbial can of worms opens quickly and widely …
]

---
template: plain
header: #### Communicate Failure between Concurrent Tasks

A basic design that communicates failure between partners working towards a
common goal is outlined in the following example.._[]
.pull-left[
The workers could look about so …
```
… f( … ,
    std::atomic_bool &die) {
    for ( … ) {
        if (die) return …;
        …
        … // some complex
        … // algorithm
        …
        // may fail here
        if ( … ) {
            die = true;
            return …;
        }
    }
}
```
]
.pull-right[
… being run by that code:
```
std::atomic_bool die{false};
auto task1 = std::async(
    [&die]{ f(… , die); }
);
auto task2 = std::async(
    [&die]{ f(… , die); }
);
…
… task1.get() …
… task2.get() …
…
if (die) {
    // goal not reached
    …
}
```
]

.F[:
To keep this code simple `f` just returns in case of problems, though it requires
only a few changes if problems should be communicated to the caller via exceptions.
]

---
template: plain
name: mutex_synchronisation
header: ### Synchronisation with Mutexes

The word *Mutex* abbreviates *Mutual Exclusion* and describe the basic purpose
of the feature.

* Allow only one thread to enter a [Critical Section], typically non-atomically
  executed sequence of statements
* which temporarily invalidate an [Class Invariant], or
* in other ways accesses a resource not designed for shared use.

.N[
In general, mutexes have at least two operations._[] for

* **lock**-ing and

* **unlock**-ing,

but frequently provide additional features to make their practical use more
convenient or less error prone.
]

[Critical Section]: http://en.wikipedia.org/wiki/Critical_section
[Class Invariant]: http://en.wikipedia.org/wiki/Class_invariant

.F[:
Though the operations may not be spelled exactly *lock* and *unlock* …
(especially as mutexes are somewhat related to [Semaphores], which originally
named their lock (-like) acquire operation *P* and their unlock (-like) release
operation *V*.
]

---
template: plain
name: mutex_example_1
header: #### Mutex Example (1)

The following example calculates one table from another one:._[]
```
template<typename In, typename Out, typename Transformation>
void worker(const In data[], std::size_t data_size,
            Out result[], std::atomic_size_t &total_progress,
            Transformation func) {
    static std::mutex critical_section;
    while (total_progress < data_size) {
        critical_section.lock();
        constexpr auto chunks = std::size_t{100};
        const auto beg = total_progress;
        const auto end = ((data_size - total_progress) > chunks)
                 ? total_progress += chunks
                 : total_progress = data_size;
        critical_section.unlock();
        std::transform(&data[beg], &data[end], &result[beg], func);
    }
}
```

.F[:
The work is shared by any number of `worker` task run concurrently, each
fetches and transforms a fixed number of values. This can be advantageous to
splitting the work by calculating fixed-size regions of the table in advance, if
the transformation function has a largely varying runtime depending on the
argument value.
]

---
template: plain
name: mutex_example_2
header: #### Mutex Example (2)

Assuming the transformation is to calculate square roots and there are
two arrays of size `N`, say

  * `data` (filled with values to transform), and
  * `sqrts` to store the results

workers may be created (to be handed over to `std::async`) as follows:._[]
```
std::atomic_size_t processed_count{0};
auto worker_task =
    [&]() { worker(data, N, sqrts, processed_count,
                   [](double e) { return std::sqrt(e); });
    };
```

.F[:
Given the above, a particular nifty way to create and run workers were:
```
  // assuming NCORES holds the number of cores to use by workers:
std::array<std::future<void>, NCORES> workers;
for (auto &w : workers)
    w = std::async(worker_task);
for (auto &w : workers)
    try { w.get(); } catch (...) {}
```
]

---
template: plain
name: mutexes_and_raii
header: #### Mutexes and RAII

As the mutex operations **lock** and **unlock** need to come correctly paired,
they make a good candidate to apply a technique called [RAII].._[]

It works by creating a wrapper class, executing

* the acquiring operation (or *lock*-ing in this case) in its constructor, and
* the releasing operation (or *unlock*-ing) in its destructor.

Such helper classes are available in C++11 `std::lock_guard`.

The big advantage is that unlocking the mutex is guaranteed for code blocks
defining a RAII-style (guard) object locally, no matter whether control
flow reached its end, or by `break`, `return`, or some exception.

.I[
For more information on the RAII-style use of mutexes see:
http://en.cppreference.com/w/cpp/thread/lock_guard
]

.F[:
This [TLA] is an abbreviation Bjarne Stroustrup once coined for *Resource
Acquisition is Initialisation*. In a recent interview Stroustrup revealed that he
is not particularly happy with the term he once choose. But to change it would
require to travel back in a time machine and suggest something more appropriate
to him, as today the term RAII is in much too widespread use to be replaced
by something else.
]

[RAII]: http://en.wikipedia.org/wiki/Resource_Acquisition_Is_Initialization
[TLA]: http://www.catb.org/jargon/html/T/TLA.html

---
template: plain
name: mutexes_and_raii
header: #### Mutex Variants

Mutexes in C++11 come in a number of flavours, which controlling their behaviour
with respect to the following details:

* Whether or not some thread that already locked a mutex may lock it once more
  (and needs to release it as often).

* Whether or not a thread waits if it finds a mutex locked by some other thread,
  and in the latter case until *when* (clock-based time point) or or *how long*
  (duration) it waits.

For all mutex variants there are also variants of RAII-style lock guards.

.I[
For more information on the different variants of mutexes and RAII-style
wrappers see:
http://en.cppreference.com/w/cpp/thread/recursive_mutex
http://en.cppreference.com/w/cpp/thread/timed_mutex
http://en.cppreference.com/w/cpp/thread/recursive_timed_mutex and
http://en.cppreference.com/w/cpp/thread/unique_lock
 
]
  
---
template: plain
name: mutexes_and_raii
header: #### C++14: Upgradable Locks

C++14 added the class `std::shared_lock`, supporting a frequent necessity:._[]

.N.center[
[Multiple Reader/Single Write Locking Schemes](http://en.wikipedia.org/wiki/Readers%E2%80%93writer_lock)
]

* Any number of (reader) threads may successfully `shared_lock` that kind of
  mutex …
* … but only one single (writer) thread is allowed to actually `lock` it
  (unshared).

C++14 also provides a RAII-style wrapper for shared locking.

.I[
For more information on shared locking see:
http://en.cppreference.com/w/cpp/thread/shared_timed_mutex and
http://en.cppreference.com/w/cpp/thread/shared_lock
]

.F[:
Note that the terms "reader" and "writer" indicates the typical use of that kind
of mutex, assuming that it is sufficient for readers to obtain the lock shared,
as it guarantees the invariants hold but no modifications are made, while writers
will need to temporarily break invariants.
]

---
template: plain
name: mutexes_and_raii
header: #### Defeating Deadlocks Caused by Mutex-Locking

As a potentially blocking mechanism mutexes are famous for creating deadlocks, i.e

* in the situation where two resources *A* and *B* are required,
* one thread acquires these in the order *first A, then B* and
* another thread acquires these in the order *first B, then A*.._[]

The obvious counter measure is to acquire locks always in the same order,
as achievable with `std::lock` and `std::try_lock`.

.I[
For more information on locking several mutexes semantically atomic (i.e.
without creating the potential for dead-locks) see:
http://en.cppreference.com/w/cpp/thread/lock and
http://en.cppreference.com/w/cpp/thread/try_lock
]

.F[:
In practice, the potential for deadlocks is often not as obvious as in this
example but much more intricate and close to impossible to spot, even in
scrutinising code reviews. So, if (accidental) deadlocks cannot be avoided,
sometimes a "self-healing" strategy is applied that works follows:  
**If more than one lock needs to be acquired, acquire at least all others with
setting a time-out.** If that hits, **release all locks** acquired so far,
**delay** for some small amount of time (usually determined in a window with
some slight randomness), then **try again** (and maybe in a different order).
]

---
template: plain
name: onetime_execution
header: ### One-Time Execution

For a particular scenario that would otherwise require the use of mutex-es to
avoid a [Race Condition], there is pre-built solution in C++11.

Executing a piece of code exactly once can be achieved in a cookbook-style as
follows:
```
// in a scope reachable from all usage points:
std::once_flag this_code_once;
…
std::call_once(this_code_once, …some callable… ); // somewhere
…
std::call_once(this_code_once, … ); // maybe somewhere else
```

For any of the callables associated with the same instance of an
`std::once_flag` via `std::call_once`, without further protection via mutexes
it is guaranteed that **at most one** is executed **at most once**.

.I[
For more information on guaranteed one time execution see:
http://en.cppreference.com/w/cpp/thread/once_flag and
http://en.cppreference.com/w/cpp/thread/call_once
]

[Race Condition]: http://en.wikipedia.org/wiki/Race_condition

---
template: plain
name: onetime_execution
header: #### One-Time Execution Example

A typical use case for guaranteed one-time execution is some initialisation,
that may be expensive and is therefore delayed until a function that depends
on it is called the first time.

The following fragment avoids parallel initialisations of `table`:
```
… foo( … ) {
    static std::once_flag init;
    static std::array<int, 1000> table;
    std::call_once(init, [&table]() {
        … // pre-calculate table when foo runs for the first time
    });
    … //
}
```

.I[
For [Static Local Variables] C++11 guarantees correct behaviour even when
`std::call_once` is not used, as outlined here:
http://en.cppreference.com/w/cpp/language/storage_duration
]

[Static Local Variables]: http://en.cppreference.com/w/cpp/language/storage_duration#Static_local_variables
---
template: plain
name: onetime_execution
header: #### Local `static` Initialisation

Since C++11 supports multi-threading in the core language, initialising local
`static` variables is protected to be executed at most once:
```
… foo( … ) {
   static const int z = expensive_calculation();
   … //
}
```

As since C++11 compilers are required to wrap the necessary protection around
the initialisation of static locals, also this is guaranteed to work:._[]
```
class Singleton {
    … //
public:
    static Singleton &getInstance() {
        static Singleton instance;
        return instance;
    }
};
```

.F[:
Non-believers should consider to copy the above code, paste it to
https://gcc.godbolt.org/ (or similar) after adding a member with a
runtime-dependant initialisation, and view the assembler output … 
]

---
template: plain
name: condition_variables
header: ### Notifications with Condition Variables

A well-known abstraction in concurrent programming are
combining mutexes with a signalling mechanism.

One main use of condition variables is to **avoid busy waiting** in
producer-consumer designs,

* where consumer and producer run concurrently,

* exchanging data over some buffer data structure.

.I[
For more information on condition variables see:
http://en.cppreference.com/w/cpp/thread/condition_variable
]

---
template: plain
name: condition_variables
header: #### Condition Variable Example (1)

The following *RingBuffer* class can put condition variables to good use …
```
template<typename T, std::size_t N>
class RingBuffer {
    std::array<T, N+1> buf;
    std::size_t p = 0, g = 0;
    bool empty() const { return p == g; }
    bool full() const { return (p+1) % buf.size() == g; }
public:
    void put(const T &val) {
        if (full())
            … // handle case no space is available
        buf[p++] = val; p %= buf.size();
    }
    void get(T &val) {
        if (empty())
            … // handle case no data is available
        val = buf[g++]; g %= buf.size();
    }
};
```
… exactly at the currently omitted points.

---
template: plain
name: condition_variables
header: #### Condition Variable Example (2)

Obviously there are two conditions, that need special attention:

* The buffer may be full when `put` is called, or
* it may be empty, when `get` is called.

Therefore two condition variables._[] are added, furthermore a mutex to protect
accessing the buffer:
```
class RingBuffer {
    … //
    … // as before
    … //
    std::condition_variable data_available;
    std::condition_variable space_available;
    std::mutex buffer_access;
public:
    … // see next page
};
```

.F[:
As the buffer space cannot be full and empty at the same time, technically
one condition variable would suffice, but for this introductory example using
two different instances seems to be clearer.
]

---
template: plain
name: condition_variables
header: #### Condition Variable Example (3)

There are two operations (of interest here), applicable to condition variables,
**sending** and **waiting for** notifications:._[]
```
class RingBuffer
   … // see previous page
public:
    void put(const T &val) {
        std::unique_lock<std::mutex> lock(buffer_access);
        space_available.wait(lock, [this]{ return !full(); });
        buf[p++] = val; p %= buf.size();
        data_available.notify_one();
    }
    void get(T &val) {
        std::unique_lock<std::mutex> lock(buffer_access);
        data_available.wait(lock, [this]{ return !empty(); });
        val = buf[g++]; g %= buf.size();
        space_available.notify_one();
    }
};
```

.F[:
Essential here is also the connection between the condition variables, the mutex
protecting the `RingBuffer` invariants, and the conditions checked as part of
waiting, which are detailed on the next page.
]

---
template: plain
name: waiting_in_details
header: #### Waiting Anatomy

Waiting on a condition variable – as shown on the last page – with
```
// as part of put:
   std::unique_lock<std::mutex> lock(buffer_access);
   space_available.wait(lock, [this]{ return !full(); });
```
```
// as part of get:
   std::unique_lock<std::mutex> lock(buffer_access);
   data_available.wait(lock, [this]{ return !empty(); });
```

is equivalent to the following, **with the mutex being locked before**:

.pull-left[
```
// as part of put:
   while (full()) { // !!full()
       buffer_access.unlock();
       // wait for notification
       buffer_access.lock();
   }
```
]
.pull-right[
```
// as part of get:
   while (empty()) { // !!empty
       buffer_access.unlock();
       // wait for notification
       buffer_access.lock();
   }
```
]

At this point **the mutex is locked** (again) and **the condition is true.**

---
template: plain
name: spurious_wakeups
header: #### Spurious Wakeups

In the example code before, the loop (in the equivalent of `wait`-ing) may seem
unnecessary, as the respective notification will be sent only after some action
has made the condition true.

Nevertheless it makes sense and may even be necessary:

* **First of all, an implementation is allowed to give [Spurious Wake-Up]s,
  so the loop is necessary anyway.**

* If notifications are sent while nobody waits on the condition variable, it is
  simply discarded, therefore

  * a producer-consumer scenario is more robust if it tends to send "too many"
    notifications (of which some are discarded) …
  * … while sending "too few" could cause some thread to wait forever.

.N[
Specifying the condition check in combination with `wait`-ing *does it right*
and hence should be preferred over writing a loop explicitly.._[]
]

[Spurious Wake-Up]: http://en.wikipedia.org/wiki/Spurious_wakeup
   

.F[:
Thus avoiding some later maintainer considers the `while` "unnecessary" and
replace it with `if` …
]

---
template: plain
name: atomic_operations
header: ### Atomic Operation Support

With the support for atomic operations C++11 multi-threading allows to implement
 
* [Wait-Free Algorithms](http://en.wikipedia.org/wiki/Non-blocking_algorithm#Wait-freedom),

* [Lock-Free Algorithms](http://en.wikipedia.org/wiki/Non-blocking_algorithm#Lock-freedom),
  and

* [Obstruction-Free Algorithms](http://en.wikipedia.org/wiki/Non-blocking_algorithm#Obstruction-freedom).

The basic concept is to provide a way to know whether a certain modification of
some memory location was caused by the current thread or by another one.

.I[
For more information about atomic operation support see:
http://en.cppreference.com/w/cpp/atomic
]

---
template: plain
name: atomic_operations_example
header: #### Atomic Operations Example

The following example, demonstrating the lock-free approach with operations
(instead of using mutexes) modifies a [former example](#mutex_example_1):
```
template<typename T1, typename T2, typename Transformation>
void worker(T1 args[], std::size_t data_size, T2 result,
            std::atomic_size_t &total_progress,
            Transformation func) {
    while (total_progress < data_size) {
        constexpr auto chunks = std::size_t{100};
        std::size_t beg = total_progress.load();
        std::size_t end;
        do {
            end = ((data_size - beg) > chunks)
                ? beg + chunks
                : data_size;
        } while (!total_progress.compare_exchange_weak(beg, end));
        std::transform(&data[beg], &data[end], &sqrts[beg], func);
    }
}
```

.N[
Be sure to understand that the loop controlled by the return value of
`compare_exchange_weak` guarantees the prior calculations are (still) valid.
]

---
template: plain
name: memory_order
header: #### Memory Order (and Dependencies)

Memory order *"specifies how regular, non-atomic memory accesses are to be ordered
around an atomic operation*".._[]

There are a number of different models to select from,

* with the default providing *"sequentially consistent ordering"*,

* being closest to what most developers would expect,

* but (possibly) not with the optimal performance for a given use case.

.I[
For more information on memory order see:
http://en.cppreference.com/w/cpp/atomic/memory_order
]

.F[:
Cited from the reference further down on this page.
]

---
template: plain
name: atomic_operations
header: #### Atomic Operations Recommendation

.N[

* Except for the potential of deadlocks the challenges are similar to algorithms
  using locks:._[]

  * Problems may only show for a critical timing and may be reproducible in
    particular test environments only.

  * In general, a failed test may show the presence of errors, but even many
    successful tests do not guarantee their absence.

]
.W[
Beyond trivial cases – like the one shown in the example –, implementing
multi-threaded programs with atomic operations requires **substantial
expertise**.

Be sure to keep the design **as simple as possible** and have it reviewed by
other developers experienced in that particular fields, maybe both, colleagues
and hired consultants too.
]

.F[:
It may very well be the case that problematic situations depend on hardware
features like the size of cache-lines, the depth of an instruction pipeline,
or the way branch prediction works.
]

---
template: plain
name: direct_use_of_threads
header: ### Using Class `std::thread`

In the examples before the class `std::thread` was used only indirectly (via
`std::async`, building on [Futures and Promises](#futures_and_promises).

* There is also a class `std::thread`
* taking any runnable code as constructor argument,
* executing it in a separate thread.

.I[
For more information on the `std::thread` class see:
http://en.cppreference.com/w/cpp/thread
]

**There are explicitly no means provided to forcefully terminate one thread
from another one.**

.W[
Any non-portable way._[] to forcefully terminate a thread risks to entail
serious consequences later, as e.g. locks may not be released or awaited
notifications not be sent.
]

.F[:
Such as potentially existing *interrupt* or *kill* functions reachable via a
[Native Interface Handle](#native_thread_handles).
]

---
template: plain
header: #### Example for Using Class `std::thread`

In case worker **returns no value** and **throws no exception**, like in a
[former example](#mutex_example_1) (and assuming the
[same set-up](#mutex_example_2)), using class `std::thread` directly can be
straight forward (left) or done in the "nifty" way (right):

.pull-left[
```
// starting some workers
// multi-threaded ...
std::thread t1{worker_task};
std::thread t2{worker_task};
…
// ... and waiting for them
// to finish:
t1.join();
t2.join();
…
```
]
.pull-right[
```
using namespace std;
constexpr auto NCORES = 4;
// starting one worker-thread
// per core ...
array<thread, NCORES> threads;
for (auto &t : threads)
    t = thread{worker_task};
// ... and wait for all to
// finish:
for (auto &t : threads)
    t.join();
```
]

An alternative to [`join`]-ing with a thread is [`detach`]-ing it.

[`join`]: http://en.cppreference.com/w/cpp/thread/thread/join
[`detach`]: http://en.cppreference.com/w/cpp/thread/thread/detach

.W[
A program will immediately terminate if an instance of class
`std::thread` referring to an active thread gets destructed.
]

---
template: plain
header: #### Recommendations for Using Class `std::thread`

.N[

* In trivial cases (no exceptions, no result to fetch) using threads via
  instances of class `std::thread` may be considered.

* Nevertheless understand the peculiarities and know how to avoid race
  conditions, especially when `std::thread` objects go out of scope.._[]

]
.W[
It causes the program to terminate if the callable started throws an
exception or an instance of `std::thread` is still in *joinable state*
when it goes out of scope and gets destructed.
]

.F[:
At [1:00:47] the following video by Scott Meyers gives a good introduction to
the problem and some recipes how it can be avoided:
http://channel9.msdn.com/Events/GoingNative/2013/An-Effective-Cpp11-14-Sampler
]

[1:00:47]: https://www.youtube.com/watch?feature=player_detailpage&v=BezbcQIuCsY#t=3646

---
template: plain
name: native_thread_handles
header: ### Native Handles

Last and finally, most C++11 multi-threading implementation build on a
threading model provided by their execution environment.

.N[
The requirements in the standard are rather the intersection of the features
provided by well-known threading models.
]

Usually and typically the standard does not mandate any any extensions thereof,
but in some cases provides a way to "reach through" to the native thread model:

* E.g. `std::thread::native_handle` could provide ways to manipulate thread
  priorities, maybe including ways to specify protocols for [Priority Ceiling]
  or other means to circumvent [Priority Inversion].

* Also the classes for condition variables and the various kinds of mutexes have
  member functions `native_handle`.

* The enumeration `std::launch` may provide more (named) values to control
  implementation specific details in the behavior of `std::async`.

[Priority Ceiling]: http://en.wikipedia.org/wiki/Priority_ceiling_protocol
[Priority Inversion]: http://en.wikipedia.org/wiki/Priority_inversion

---
template: plain
name: concurrency_recommendations
header: ### Concurrency Recommendations

So far the presentation of C++11 concurrency support was only meant as an
overview.

.W[
Practically using concurrency features beyond parallelizing independent tasks
requires much more knowledge and experience in this area, what this presentation
can not provide.
]

A good and near to exhaustive coverage of the concurrency part of C++11 is:

.N.center[
C++ Concurrency in Action  
Practical Multithreading  
by Anthony Williams  
[ISBN-13: 978-1-9334988-77-1](http://www.cplusplusconcurrencyinaction.com)
]

---
template: plain
name: boost_thread
header: ## Boost: Threads Library

[Boost.Thread]: http://www.boost.org/doc/libs/release/doc/html/thread.html

As C++11 threads emerged from [Boost.Thread] there is little difference.

Some differences between C++11 and Boost may exist (depending on the version
of the latter) and new features may appear and be tried in Boost first before
eventually getting part of an upcoming C++ standard.

.N[
There are many reasons why a pure library solution may have practical
difficulties to properly support concurrency.

Most important is in the memory model, which needs to be clearly defined so
that optimising compilers are restricted to the necessary limits – but not
(too far) beyond these.._[]
]

.F[:
A related, easy to recognize problem that demonstrates why concurrency cannot
be added as a library alone but must be part of the core language part, can be
seen when considering a long-existing features of C which is also part of C++:
the initialization of local `static` variables. By definition this takes place
when the definition is reached in the program flow for the first time and hence,
in the general case must be protected with a mutex (or similar) to avoid race
conditions (except for initialisation with a compile-time constant that can be
loaded at program startup).
]

---
template: plain
name: cpp11_tuples_more_boost
header: ## Tuples and More

---------------------------------------------------------------------------

* [C++11 / Boost Tuple				](#cpp11_tuple)
* [Boost Optional				](#boost_optional)
* [Boost Any					](#boost_any)
* [Boost Variant				](#boost_variant)

---------------------------------------------------------------------------

---
template: plain
name: cpp11_tuple
header: ### C++11: Tuple

Tuples are kind of ad-hoc structures and are mainly used to temporarily combine
several unrelated values to be handled as unit, e.g. in a function result.

The similarity of `std::tuple` to `std::pair` for the above use case is obvious
and if tuples had been part of C++98 they would have probably been used in some
places were currently `std::pair` is used.

.N[
Because the number of elements in a tuple is unlimited._[] they cannot be names
(like `first` and `second` in a pair) and a different technique must be applied
to access the individual parts of a tuple.
]

.F[:
Interestingly, the other border case are not tuples with a single element, but
completely empty ones. These not only may have some use in very generic,
templated data structures but can also help to write compile time algorithms
to process all elements of a tuple. This can be done by recursive calls of
variadic templates, terminated with a specialization for the (degenerate) empty
tuple.
]

---
template: plain
name: cpp11_tuple_def_init
header: #### Definition and Initialization of `std::tuple`

When defining a tuple the type of its elements may be explicitly defined:
```
std::tuple<int, double, const char *> t;
```

This may – of course – be combined with an initialization:._[]
```
std::tuple<int, double, const char *> t{42, std::sqrt(2), "hello"};
```

.F[:
And of course any classic initialization syntax may be used here in place of
the curly braces style.
]

Types can be omitted by using `auto`:
```
auto t = std::make_tuple(42, std::sqrt(2), "hello");
// or:
auto t(std::make_tuple(42, std::sqrt<float>(2), "hello"));
```

**But:** As a subtlety of "uniform initialization" the following creates a tuple
too, though quite a different one:
```
auto t{std::make_tuple(42, std::sqrt(2), "hello")};
```

---
template: plain
name: cpp11_tuple_get_element
header: #### Element Access of `std::tuple`

To access individual elements a global getter-function must be used:
```
… std::get<0>(t) …	// the int
… std::get<1>(t) …	// the double
… std::get<2>(t) …	// the const char *
```

.W[
It should be understood that the "element index" for `std::get` has to be a
compile time constant.
]

Therefore the following will not work:._[]
```
for (int i = 0; i < 3; ++i) std::cout << std::get<i>(t) << '\n';
```

.F[:
There are ways to print all the elements of a tuple – but it must be done with
a loop *unrolling itself completely at compile time*, as for each element a
different overload of `operator<<` might have to be used.
]

---
template: plain
name: cpp11_tuple_unpacking
header: #### Unpacking an `std::tuple`

There is a different technique that unpacks all elements of a tuple at once:
```
int count;
double value;
const char *name;
std::tie(count, value, name) = t;
```

Obviously this has its greatest advantage if all values have to go into a
variable of their own, or at least most values:
```
int count;
std::string name;
std::tie(count, std::ignore, name) = t;
```

.N[
Compared to element access with `std::get` it is said that a small overhead may
be imposed by `std::tie`, but surely far from substantial.._[]
]

.F[:
Vague language is used here to indicate that details will vary between
implementations and future compilers may apply code-generation techniques to
improve chances for optimization, putting `std::tie` at par with direct
member assignment.
]

---
template: plain
name: cpp11_tuple_modification
header: #### Modifying `std::tuple`

As `std::get` returns a reference, it is straight forward to modify individual
elements of a tuple:
```
std::get<0>(t) = 12;
std::get<1>(t) *= 2;
```

Tuples can be also modified as a whole, only given each of their elements are
assignment compatible:
```
std::tuple<int, double> t1{3}, t2{12, std::sqrt(2)};
auto t3 = std::make_tuple(true, 0u);
t1 = t2; t2 = t3; t3 = t1;
```

Assigning all elements at once fails if some or all are `const`-qualified:
```
std::tuple<const int, double> t4{-1, 0.0};
const std::tuple <int, double> t5{0, 0.0};
t1 = t4; // OK (of course can assign FROM const)
t4 = t1; // FAILS because first member is const
t5 = t1; // FAILS because all members are const
std::get<1>(t4) = std::get<1>(t1); // OK
```

---
template: plain
name: boost_tuple
header: #### Boost: Tuple

[`boost::tuple`]: http://www.boost.org/doc/libs/release/libs/tuple/doc/tuple_users_guide.html

C++11 `std::tuple` emerged from [`boost::tuple`].

There are few differences most of which are related to lifted restrictions
because C++11 supports true variadic templates.

* With `std::tuple` there is no upper limit to the number of contained elements.

* For `boost::tuple` the maximum is limited – usually to 10 or 20, depending on
  the configuration step (optionally) run as first thing during the Boost
  installation.

Another difference is that `std::tuple` can **only** be accessed with the global
getter while `boost::tuple` also has a member for that purpose:._[]
```
… std::get<2>(t) …  // C++11 and Boost
… t.get<2>() …      // Boost only
```

.F[:
Of course, here `t` is assumed to be a tuple with at least three elements.
]

---
template: plain
name: boost_optional
header: ### Boost: Optional

[`boost::optional`]: http://www.boost.org/doc/libs/1_56_0/libs/optional/doc/html/index.html
[Placement `new`]: http://en.wikipedia.org/wiki/Placement_syntax
[Explicit Destructor Call]: http://www.parashift.com/c++-faq/dtors.html

The use of `boost::optional` may be considered as an alternative to using
pointers and having the `nullptr` represent the *does-not-exist* case.

* Differently from the pointer approach with `boost::optional` no heap
  allocation will occur.

  * Instead `boost::optional` reserves space for its payload data type
    **plus** a flag (e.g. on the stack in case of a local variable) …

  * … uses [Placement `new`] when the payload space is eventually to be
    initialized …

  * … and an [Explicit Destructor Call] when it is to be invalidated.

```
boost::optional<int> x; // default initialized …
assert(!x);             // ... it's not yet valid ...
x = 42;                 // ... now gets assigned ...
assert(x);              // ... tested here ...
assert(x.get() == 42);  // ... retrieved here
```

---
template: plain
name: boost_any
header: ### Boost: Any

[`boost::any`]: http://www.boost.org/doc/libs/1_56_0/doc/html/any.html

The use of [`boost::any`] may be considered as an alternative to using untyped
pointers (`void *`) to achieve "runtime polymorphism" for types that cannot be
related through a common base class.

* Internally `boost::any` refers to the assigned data via a `void*` member …

* … while with an additional member it tracks the type assigned last …

* … for which it can be queried in a convenient syntax.

```
boost::any x;               // default initialized to nullptr
if (…)                      // depending on a runtime condition ...
    x = true;               // ... may actually hold a boolean ...
else if (…)                 // ... or in a different case ...
    x = std::sqrt(2.0);     // ... may actually hold a double ...
else if (…)                 // ... or yet differently ...
    x = std::string("hi!"); // ... an std::string ...
else                        // ... or ...
    x = …;                  // ... (who knows?)
```

---
template: plain
name: boost_any2
header: #### Boost: Any (cont.)

To access a `boost::any` its content type must always be tested for.

There is a rather systematic way to do so:._[]
```
if (bool *p = boost::any_cast<bool>(&x)) {
    … *p … // access member if of type bool
}
else if (double *p = boost::any_cast<double>(&x)) {
    … *p … // access member if of type double
}
else if (std::string *p = boost::any_cast<std::string>(&x)) {
    … *p … // access member if of type std::string
}
```

.F[:
Here a lesser known feature from C++98 is at work, allowing to define a
variable inside an `if`-condition so that it gets local scope, limited to the
statement or block following, much like it is often used for counting variables
in `for` loops.
]

.N[
The pointers `p` can also be `auto` or `auto *`-typed.
]

That way there is **only one** type to adapt when a code block gets copy-pasted
to implement a new type case branch.

---
template: plain
name: boost_variant
header: ### Boost: Variant

[`boost::variant`]: http://www.boost.org/doc/libs/1_56_0/doc/html/variant.html

The type [`boost::variant`] is similar to `boost::any` with the important
exception that the set of types must be known at compile time:._[]
```
boost::variant<bool,
              std::string,
              double> x;  // from a (default initialized) bool
…                         // (as bool is the first on the list)
x = std::sqrt(2.0);       // can be set to any other type from
…                         // the list, either exactly matching
x = std::string("hello"); // but also applying conversions, if
…                         // an unambiguous choice can be made,
x = "world";              // like const char * to std::string
x = nullptr;              // or nullptr_t to bool (-> false)
```

.F[:
Effectively this means that there is a closer coupling to the client code as for
`boost::any`, where the set of types involved of course is also fixed in the
source code, but more remotely, i.e. only in the context of initialization,
assignment, and value access.
]

.N[
Therefore it can be used as replacement for a classic C-style `union` augmented
with a type tracking member automatically set on initialization and assignment.
]

---
template: plain
name: boost_variant2
header: ### Boost: Variant (cont.)

A variant can be accessed in several ways:

* Specifying the expected type directly, e.g. with `boost::get<bool>(x)`, with
  an exception thrown when the content is different.

* By trying a type with `auto *p = boost::get<bool>(&x)`, followed by an
  explicit or implicit test against the `nullptr`.._[]

* With a compile time variant of the visitor pattern.

.F[:
In so far it is similar to `boost::any` but with slightly different syntax.
]

```
struct process : boost::static_visitor<> {
    void operator()(bool b) const { … } // process content if bool
    void operator()(double d) const { … }         // ... if double
    void operator()(const std::string &s) const { … }  // ... etc.
};
…
boost::apply_visitor(process(), x);
```

.N[
Note that applying a visitor detects missing cases at compile time!
]

---
template: plain
name: boost_variant3
header: ### Boost: Variant (cont.)

In vistor-style there is also the option to fold cases with common source code
into a template, while still handling special cases special:._[]
```
struct print : boost::static_visitor<> {
    std::ostream &os;
    print(std::ostream &os_) : os(os_) {
        os.setf(ios::boolalpha);
    }
    template<typename T>
    void operator()(const T &v) const {
        os << v;
    }
    void operator()(const std::string &v) const {
        os << '"' << v << '"';
    }
};
…
boost::apply_visitor(print(std::cout), x);
```

.F[:
An overloaded `operator<<` is already defined for `boost::variant` but of
course without any special-casing.
]

.N[
Missing type cases now might not have the required implementation.
]
---
template: plain
name: thursday2
header: ## C++11 Smart Pointers

---------------------------------------------------------------------------

* [Smart Pointer Overview			](#smart_pointer_overview)
* [C++11: `std::shared_ptr`			](#cpp11_shared_ptr)
* [C++11: `std::weak_ptr`			](#cpp11_weak_ptr)
* [C++11: `std::unique_ptr`			](#cpp11_unique_ptr)
* [Deprecated `std::auto_ptr`			](#deprecated_auto_ptr)
* [Boost: Smart Pointers			](#boost_smart_pointer)
* [Boost: Pointer Container			](#boost_pointer_container)
* [Garbage Collection				](#garbage_collection)

---------------------------------------------------------------------------

---
template: linkinfo
graphic: SmartPointers
name: smart_pointer_overview
header: ### Smart Pointer Overview

With C++11 a number of "smart" pointers were standardised.

They come in three flavours:

* `std::unique_ptr` (exclusively "owning" the referred-to memory)

* `std::shared_ptr` (sharing ownership)

* `std::weak_ptr` (helping to break cycles)

---
template: plain
name: cpp11_shared_ptr
header: ### C++11: `std::shared_ptr`

[`std::shared_ptr`]: http://en.cppreference.com/w/cpp/memory/shared_ptr
[Smart Pointer]: http://en.wikipedia.org/wiki/Smart_pointer

With [`std::shared_ptr`] C++11 introduced a [Smart Pointer] type that does
reference counting on its pointee:

* When created by its default constructor it points to no object and creates
  an owner (reference) count set to zero.

* When created and initialized with a bare pointer it assumes it is the first
  and only one and creates an owner count set to 1.

* When initialized from another of its kind it points to the same object as the
  other (if any) and increments the – then shared – owner count.

* When assigned from another of its kind it first decrements the owner count and
  if that drops to zero, destroys the pointee; then it continues as if it were
  initialized from the pointer assigned to it.

* When it goes out of scope it also decrements the owner count and if that drops
  to zero, destroys the pointee.

---
template: plain
name: shared_pointee_init
header: #### Shared Pointee Construction

Per default an `std::shared_ptr` is initialized with no pointee.

Given
```
class MyClass { … MyClass(bool, double, std::string); … };
```

an `std::shared_ptr` can be initialized to point to a heap allocated object of
type `MyClass` as follows:._[]
```
std::shared_ptr<MyClass> p1{new MyClass(true, 3.14, "hi!")};
```

Or:
```
auto p2 = std::make_shared<MyClass>(true, 3.14, "hi!");
```

The usual recommendation is to prefer the second way over the first as it can
reserve space for `MyClass` together with the helper object (holding owner and
observer count._[]) in a single heap allocation.

.F[:
The observer count has not yet been introduced; its purpose will become clear
when [`std::weak_ptr`](#cpp11_weak_ptr) gets explained.
]

---
template: plain
name: shared_pointee_access
header: #### Shared Pointer Access

Given an `std::shared_ptr<SomeType> p` the most typical access to the pointee is
via overloaded `operator*` or `operator->`, possibly after a testing whether
there is an object:._[]
```
if (p) … *p …; // access whole object
       … p->m …; // access data member m
       … p->f(); // call member function f
```

Furthermore `p.get()` returns the address of the pointee (or `nullptr`), so

* it can bridge between `std::shared_ptr` and legacy code that expects a native
  pointer,

* at least as long as the recipient is short-lived (compared to `p`) and

* **does not assume ownership**.

---
template: plain
name: shared_pointee_destruct
header: #### Shared Pointee Destruction

The default way to destruct the pointee (when the owner count drops to zero) is
with `delete`.

If this is not appropriate a custom deleter can be specified at construction
time:
```
std::shared_ptr<std::FILE> auto_close_fp{
    std::fopen("somefile", "r"),
    [](FILE *fp) { if (fp) std::fclose(fp); }
};
```

If the pointee is guaranteed to be valid or a custom deleter with a single
pointer argument of pointee-type that is `nullptr`-safe._[] it could be
specified directly:
```
if (auto fp = fopen("myfile", "w")) {
   std::shared_ptr<std::FILE> auto_close_fp{fp, std::fclose};
   …
}
```

.F[:
Implementations of `fclose` differ in C, some are more robust and check the
pointer argument for `(FILE*)0`, but according to the C-Standard an invalid
pointer causes undefined behavior.
]

---
template: plain
name: cpp11_weak_ptr
header: ### C++11: `std::weak_ptr`

[`std::weak_ptr`]: http://en.cppreference.com/w/cpp/memory/weak_ptr

With [`std::weak_ptr`] C++ introduced a companion to `std::shared_ptr`, mainly
used to break cyclic references, which would otherwise defeat one of the main
motivations for using smart pointers as a light-weight, high-efficiency
garbage collector.

* An `std::weak_ptr` acts as **observer** of a pointee **owned** by an
  `std::shared_ptr`.

* As such it shares and manages an observer count (similar to but different from
  the owner count).

* A non-zero observer count **will not keep the pointee alive** if the owner
  count drops to zero.

* Therefore an `std::weak_ptr` has no way to access the pointee directly via
  overloaded `operator*` or `operator->`.

* To gain access it has first to obtain an `std::shared_ptr` – which might fail
  but if successful will keep the pointee alive even if all other owners cease
  to exist.

---
template: plain
name: shared_pointee_usage
header: #### Weak Pointee Usage

Per default an `std::weak_ptr` is initialized with no pointee.

Given `std::shared_ptr<MyClass> p` an `std::weak_ptr` can be initialized to the
pointee referred by `p` (if any) with:
```
std::weak_ptr<MyClass> wp{p};
```

The other way round – initialising an `std::shared_ptr<MyClass>` from `wp` –
also works but will throw if `wp` has been invalidated in the meantime.

Also it is possible to obtain an `std::shared_ptr` and test it for validity in
the following way:
```
if (auto sp = wp.lock()) {
    // sp != nullptr
    // now owns the object wp had observed
    … *sp …;   // access whole object
    … sp.m …;  // access data member m
    … sp->f(); // call member function f
} // sp goes out of scope, if all other owners
  // are gone pointee will get destroyed here
```

---
template: plain
name: cpp11_unique_ptr
header: ### C++11: `std::unique_ptr`

[`std::unique_ptr`]: http://en.cppreference.com/w/cpp/memory/unique_ptr

An [`std::unique_ptr`] is – as the name suggests – the sole owner of its
pointee:

* Therefore there can always be only one for each pointee, i.e.

  * it is **not possible** to copy-construct or copy-assign an `std::unique_ptr`
    from another one of its kind (yields a compile time error), but

  * it **is possible** to move-construct or move-assign an `std::unique_ptr`
    from another one of its kind.

* When an `std::unique_ptr` goes out of scope or is re-assigned it first
  destroys its pointee (if any).

.N[
The implementation of `std::unique_ptr` is very close to native pointers, i.e.
same memory footprint, and also for most operations same performance, except
those that need to care for destruction of a (previous) pointee.
]

---
template: plain
name: unique_pointee_init
header: #### Unique Pointee Construction

Per default an `std::unique_ptr` is initialized with no pointee.

Given any type `T` (a built-in type, a class from the standard library, or a user
defined class) an `std::unique_ptr` can be initialized to point

* to a **single heap allocated object of this type**._[]
```
std::unique_ptr<T> ptr{new T};
```

* or to an **array of `N` heap allocated objects**:
```
std::unique_ptr<T[]> arr{new T[N]};
```

.I[
The appropriate deleter is set depending on the template instantiation argument
`T` or `T[]`.
]

.F[:
Constructor arguments may be supplied as usual but there is no
`std::make_unique` analogous to `std::make_shared` until C++14.
]

---
template: plain
name: unique_pointee_access
header: #### Unique Pointer Access

Given an `std::unique_ptr<SomeType> p` the most typical access to the pointee is
via overloaded `operator*`, `operator->`, or `operator[]` if the pointee is an
array, possibly after a testing whether there is an object:._[]
```
if (p) … *p …; // access whole object
       … p->m …; // access data member m
       … p->f(); // call member function f
       … p[i] …; // access i-th whole object (0-origin)
```

Furthermore

* `p.get()` returns the address of the pointee (or `nullptr`), so it can bridge
   between `std::unique_ptr` and legacy code that expects a native pointer with
   shorter lifetime as `p`;

* `p.release()` is similar but relinquishes ownership of the pointee **which the
   recipient has to assume then**.

---
template: plain
name: unique_pointer_move
header: #### Moving Unique Pointers

As unique pointers can not be copied, the (deliberate) use as initial values for
copy constructor arguments is not possible:
```
extern std::unique_ptr<MyClass> make_MyClass();
…
std::unique_ptr<MyClass> p1 = make_MyClass(); // OK (move c'tor)
std::unique_ptr<MyClass> p2(p1); // ERROR (no copy c'tor exists)
```

Instead the exsting pointer needs to be moved:
```
std::unique_ptr<MyClass> p3(std::move(p1)) // OK (p1 nullptr now!)
```

Same for assignment – move works, copy does not:
```
p1 = p3;             // ERROR (no copy assignment exists)
p1 = make_MyClass(); // OK (move assignment)
p1 = std::move(p3);  // OK (p3 nullptr now!)
```

---
template: plain
name: shared_pointee_destruct
header: #### Unique Pointee Destruction

Per default the pointee is destructed with `delete` or `delete[]` depending on
the way an `std::unique_ptr` has been created. Wrong pairing will not be
detected at compile time but cause undefined runtime behaviour.._[]
```
{ std::unique_ptr<T[]> ptr{new T};
  …
} // destructor does delete[] on pointee address
```

Or:
```
{ std::unique_ptr<T> arr{new[N] T};
  …
} // destructor does delete on pointee address
```
.W[
Pairing plain allocation with array deallocation or array allocation with plain
deallocation has undefined behavior.
]

.F[:
In the best case this will cause an immediate crash with a good error message.
But a crash may also occur much later with a misleading error message (if any)
and therefore may be hard to relate to its original cause, or there may be a
memory leak, memory overwritten with bad values, whatever …
]

---
template: plain
name: deprecated_auto_ptr
header: ### Deprecated `std::auto_ptr`

[`std::auto_ptr`]: http://en.cppreference.com/w/cpp/memory/auto_ptr
[Smart Pointer]: http://en.wikipedia.org/wiki/Smart_pointer

The only [Smart Pointer] in C++98 was [`std::auto_ptr`], which is deprecated
since C++11.

* It had nearly the same behavior (and implementation) as `std::unique_ptr` has
  now, but C++98 had no means to forbid the copying versions of constructor and
  assignment while still allowing the move versions.

* Therefore `std::auto_ptr` had copy-constructor and -assignment which set their
  right hand side to `NULL`, i.e. the auto-pointer used for initialisation or
  from which the pointee was assigned lost its pointee.

* **That came as a surprise to some developers who expected a "more intelligent"
  behaviour from a "smart pointer".**

.N[
Or as Bjarne Stroustrup once put it: With C++11 `std::unique_ptr` became what
`std::auto_ptr` in C++98 always should have been but couldn't, due to lacking
proper language support.
]

---
template: plain
name: boost_smart_pointer
header: ### Boost: Smart Pointer

[Smart Pointer]: http://en.wikipedia.org/wiki/Smart_pointer

The term *Smart Pointer* is also used to subsume pointer-like helper classes
in Boost:

* `boost::shared_ptr`:  
   much like `std::shared_ptr` (the latter mostly emerged from the former);

* `boost::weak_ptr`:  
   much like `std::weak_ptr` (the latter mostly emerged from the former);

* `boost::scoped_ptr` and `boost::scoped_array`:  
   close to `std::unique_ptr` but in two variants to provide different
   destructors to do a plain `delete` or a `delete[]` on the pointee.

* `boost::intrusive_ptr`:  
   similar in purpose to `boost::shared_ptr` / `std::shared_ptr` but storing the
   reference count inside the pointee (which therefore must be accessible).

---
template: plain
name: boost_scoped_pointer
header: ## Boost: Scoped Pointer

[Scoped Pointer]: http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_ptr.htm

A [Scoped Pointer] considers itself to be the sole owner of a

* **single object allocated on the heap**

and will finally destroy its pointee (if any) when going out of scope or a new
pointee is assigned.

* There is no copy-constructor and -assignment, the only way to re-assign a
  `boost::scoped_ptr` is via `swap` (available globally and as member function);

* Final destruction will use `delete`, therefore expecting the pointee is a
  single object.

.W[
If a `boost::scoped_ptr` is initialized with an address not returned from `new`
or is pointing to an array of objects returned from array heap allocation,
undefined behaviour will result at deletion time.
]

---
template: plain
name: boost_scoped_array
header: ## Boost: Scoped Array

[Scoped Array]: http://www.boost.org/doc/libs/release/libs/smart_ptr/scoped_array.htm

A [Scoped Array] considers itself to be the sole owner of

* **an array of objects allocated on the heap**

and will finally destroy its pointee (if any) when it goes out of scope or a new
pointee is assigned.

* There is no copy-constructor and -assignment, the only way to re-assign a
  `boost::scoped_array` is via `swap` (available globally and as member
  function);

* Final destruction will use `delete[]`, therefore expecting the pointee is an
  array of objects.

.W[
If a `boost::scoped_array` is initialized with an address not returned from
`new` or pointing to a single object returned from plain heap allocation,
undefined behaviour will result at deletion time.
]

---
template: plain
name: boost_intrusive_pointer
header: ## Boost: Intrusive Pointer

[Intrusive Pointer]: http://www.boost.org/doc/libs/release/libs/smart_ptr/intrusive_ptr.html

An [Intrusive Pointer] is much like a reference counted `boost::shared_ptr` or
`std::shared_ptr`.

* Instead of allocating reference counts separately it expects two global
  functions overladed for pointers to the pointee's type:

  * `intrusive_ptr_add_ref` – called when a new referrer for the pointee is
    added.

  * `intrusive_ptr_release` – called when an existing referrer of the pointee
    gets re-assigned or goes out of scope.

* Furthermore there is a class `boost::intrusive_ref_counter` from which the
  pointee's class may be derived.._[]

.N[
Boost recommends in case of doubt to prefer ordinary shared pointers and to
avoid using intrusive pointers without good reason.
]

.F[:
Of course given its source is written from scratch or at least available and can
be modified.
]

---
template: plain
name: intrusive_pointer_example
header: ### Intrusive Pointer Example

To make `MyClass` usable with intrusive pointers it can be written as:._[]
```
class MyClass :
    public boost::intrusive_ref_counter<
                      MyClass,
                      boost::thread_unsafe_counter
           > { … };
```

Or if it should be usable in a multi-threaded environment:
```
class MyClass
    : public boost::intrusive_ref_counter<
                        MyClass,
                        boost::thread_safe_counter
             > { … };
```

Then there can be intrusive pointers of `MyClass`:
```
boost::intrusive_ptr<MyClass> p{new MyClass(…)};
```

.F[:
The second template argument may be omitted as it defaults to
`boost::thread_unsafe_counter`.
]

---
template: plain
name: boost_pointer_container
header: ## Boost: Pointer Container

A number of [Pointer Containers] has been made available by boost, paralleling
the STL containers with a pointer version that

* omits the pointer syntax at instantiation,

* adds one level of dereferencing to each member access, and

* considers its elements as pointers owning the memory pointed to.

While the former two are more a matter of convenience (see example on next
slide), the last one has a severe semantical implication:

* If the container goes out of scope it deletes all the pointees of its (still)
  contained elements.._[]

.F[:
This effect can alternatively be achieved by storing `std::unique_ptr`-s in an
ordinary container.
]

.W[
Storing non-owning pointers or pointers that do not even point to heap-allocated
memory in a pointer container will cause undefined behaviour when or after the
container goes out of scope.
]

---
template: plain
name: pointer_container_example
header: ### Pointer Container Example

Storing and later on processing a `boost::ptr_vector`:._[]
```
boost::ptr_vector<MyClass> v;
…
// fill in some content (probably in a loop):
… v.push_back(new MyClass(…));

// process later (or maybe in a different thread):
while (!v.empty()) {
   … v.back() …; // access MyClass as a whole
   … v.back().m …; // access MyClass data member
   … v.back().f(); // call MyClass member function
   v.pop_back();
}
```

.N[
In case the processing loop is not reached or left before the content is fully
processed, **the pointer container destructor** will call `delete` for the
pointers still contained, avoiding a memory leak.
]

.F[:
If a pointer container actually gets filled and processed concurrently as
suggested by the comment in the example, mutexes or other synchronization
techniques must be added as modifying operations are not thread-safe by
themselves.
]

---
template: plain
name: pointer_container_substitute
header: ### Pointer Container Substitute

Storing and later on processing a container of custodial pointers:._[]
```
std::vector<std::unique_ptr<MyClass>> v;
…
// fill in some content (probably in a loop):
… v.emplace_back(new MyClass(…));

// process later (or maybe in a different thread):
while (!v.empty()) {
   … *(v.back()) … // access MyClass as a whole
   … v.back()->m … // access MyClass data member
   … v.back()->f() … // call MyClass member function
   v.pop_back();
}
```

.F[:
If an STL container actually gets filled and processed concurrently as suggested
by the comment in the example, mutexes or other synchronization techniques must
be added as modifying operations are not thread-safe by themselves.
]

.N[
In case the processing loop is not reached or left before the content is fully
processed, **the `std::unique_ptr` destructors** will call `delete` for their
pointees, avoiding a memory leak.
]

---
template: plain
name: garbage_collection
header: ## Garbage Collection

There is no garbage collection in C++ because of a specific difficulty:

* **An address once obtained from `new` may not be visible in any memory
  location capable of holding a heap address**, instead it

  1. may have been modified by address arithmetic … which will of course be
     reverted before the `delete` takes place;

  2. may be temporarily stored in an integral type._[] … and will of course be
     restored to a pointer of appropriate type before the `delete` takes place.

.N[
Both are not a sign of bad programming style but have some valid uses in the C
and C++ code base written in the last 35 years, so they cannot be easily ruled
out by a new language standard.
]

.F[:
C/C++ even guarantees that when an integral type of sufficient size is used as
temporary to store a pointer, after assigning the content back to the original
pointer type the memory location pointed to will not have changed … which by
no means says that the bit patterns stays the same all the time!
]

---
template: plain
name: cpp11_gc_interface
header: ### C++11: Garbage Collection API

[Garbage Collection ABI]: https://isocpp.org/wiki/faq/cpp11-library#gc-abi
C++11 has defined an [Garbage Collection ABI] to enable *Interested Third
Parties* to supply garbage collection as add-on library.._[]

Mainly the ABI allows to say (put colloquially):

* **The object at this address I name to you may appear not to be any longer in
  use.**

  * You may not find it in any memory location capable of holding a heap
    pointer. Nevertheless be assured: it *is* still in use, so *do not garbage
    collect it*, I'll take up responsibility and return the reserved space in
    due course when its *really* not in use any more.

* **In this memory area I name to you, you may find storage cells looking like
  pointers to heap memory, but they aren't.**

  * So, in case there is any memory pending to be freed and *its only use
    appears to be from inside this area*, feel free to go ahead and garbage
    collect that stuff.

.F[:
It will surely be interesting to watch such efforts and whether any third-party
garbage collector for C++ gets into wide-spread use. If so, then probably rather
for new software, not for large amounts of legacy code (including libraries),
and maybe only with additional support by compiler warnings.
]

---
template: plain
name: more_of_boost
header: ## More (Parts of) Boost

---------------------------------------------------------------------------

* [Asynchronous Input and Output		](#boost_asio)
* [Accessing the File System			](#boost_filesystem)
* [Loosely Coupled Components			](#boost_signals2)
* [Inter-Process Communication			](#boost_interprocess)

---------------------------------------------------------------------------

---
template: plain
name: boost_asio
header: ### Boost: Asio

[Boost.Asio]: http://www.boost.org/doc/libs/release/doc/html/boost_asio.html

The purpose of [Boost.Asio] is to support event-driven program designs by
providing a framework to dispatch incoming events to previously registered event
handlers:

* The largest group of events deals with I/O, especially the arrival of data
  from asynchronous sources (like sockets).

* Besides that it allows also an applications to send events to itself, maybe
  with a specified delay.

Event handlers are run single-threaded and hence there is no need for
synchronisation as is in multi-threaded designs. For good responsiveness an
event driven program design must keep event handlers small.

.N[
Especially an event handler should **never** delay or wait for responses of
an external client – rather register an handler to be started when the
response arrives.
]

---
template: plain
name: boost_filesystem
header: ### Boost: File System

[Boost.Filesystem v2]: http://www.boost.org/doc/libs/1_49_0/libs/filesystem/v2/doc/index.htm
[Boost.Filesystem V3]: http://www.boost.org/doc/libs/1_49_0/libs/filesystem/v3/doc/index.htm
[TR2 Path]: http://en.wikipedia.org/wiki/C%2B%2B_Technical_Report_1#Technical_Report_2
[Microsoft Visual Studio 2013]: http://msdn.microsoft.com/en-us/library/hh874694.aspx

Even with C++11 there is no portable way to access the file system to

* search through directories and sub-directories,

* determine and change file properties,

* delete, rename, link, or copy files.

.N[
Boost had tried to tackle this since a long time – with more or less success –
and is currently in its 3rd major release [Boost.Filesystem V3].
]

This file system library may also – via the [TR2 Path] – become available with
recent Standard C++ versions and is part of [Microsoft Visual Studio 2013].

.F[:
At the time of writing the final state of affairs is not quite clear. A major
obstacle through all the years seems to have been uniting the classic and also
modern 8-bit-char API of Unix/Linux (using UTF-8 now, which the clients – by and
large – can handle "content-agnostic") with the 16-bit-char API of MS-Windows in
a portable way …
]

---
template: plain
name: boost_signals2
header: ### Signals2

[Boost.Signal]: http://www.boost.org/doc/libs/release/doc/html/signals.html

From the Boost Documentation:
.N[
The [Boost.Signal] Library is an implementation of a managed signals and slots
system. Signals represent callbacks with multiple targets, and are also called
publishers or events in similar systems. Signals are connected to some set of
slots, which are callback receivers (also called event targets or subscribers),
which are called when the signal is "emitted."
]

---
template: plain
name: boost_interprocess
header: ### Interprocess Communication (IPC)

[Boost.Interprocess]: http://www.boost.org/doc/libs/release/doc/html/interprocess.html

From the Boost Documentation:
.N[
[Boost.Interprocess] simplifies the use of common interprocess communication and
synchronization mechanisms and offers a wide range of them:

* [IPC Overview](#ipc_overview)
* [Shared Memory](#shared_memory)
* [Memory-Mapped Files](#memory_mapped_files)
* [Various Synchronization Mechanisms](#various_synchronization)
* [File Locking](#file_locking)
* [Relative Pointers](#relative_pointers)
* [Message Queues](#message_queues)
]

---
template: plain
name: ipc_overview
header: #### IPC Overview

Boost.Interprocess works with both, [Threads or Processes]

[Threads or Processes]: http://www.boost.org/doc/libs/release/doc/html/interprocess/some_basic_explanations.html#interprocess.some_basic_explanations.processes_and_threads

Which of both is chosen mainly depends on design criterias:

* Threads operate in the same address space and hence (e.g.)
  * can share data easily via global variables, and
  * are usually a bit more "light-weight"
    * (somewhat) faster to create
    * less ressource consuming
* Processes are strictly shielded from each, so they
  * need to be more explicit to share common data.

.N[
Processes – in comparison to threads – are **in much less risk** of what is
sometime called "accidental sharing"._[]
]

.F[:
I.e. sometimes more explicit copying may be necessary when processes are used
but there are usually also fewer hard to chase bugs, manifesting themselves in
data inconsitencies last and finally caused by race conditions missed by the
developer.
]

---
template: plain
name: shared_memory
header: #### Shared Memory

[Shared Memory] is a very fast mechanism to exchange,

* as well between two process
  – which then **may have** common memory mapped to different addresses

* and also between two threads
  – which thereby can avoid global variables and hence have more privacy
  in relation to each other

Typically shared memory needs to be combined with a synchronisation mechanism
to avoid race conditions when data is modified or a non-busy waiting feature.

.N.center[
**NOTE**  
All the code fragments showing the use of shared memory on the following pages
are copied from the [Boost Documentation], with minor modifications.
]

[Boost Documentation]: http://www.boost.org/doc/libs/release/doc/html/interprocess/sharedmemorybetweenprocesses.html

---
template: plain
header: ##### Creating Shared Memory

A shared memory object **`shm_obj`** can be created as follows:
```
boost::interprocess::shared_memory_object shm_obj
   {create_only                  //only create
   ,"shared_memory"              //name
   ,read_write                   //read-write mode
   };
```

---
template: plain
header: ##### Attaching to Shared Memory

The following opens (attaches to) a shared memory object **`shm_obj`** that
already has been created:
```
boost::interprocess::shared_memory_object shm_obj
   {open_only                    //only open
   ,"shared_memory"              //name
   ,read_write                   //read-write mode
   };

```

---
template: plain
header: ##### Creating and Attaching Combined

Creating and attaching to shared memory **`shm_obj`** can also be combined:
```
boost::interprocess::shared_memory_object shm_obj
   {open_or_create               //open or create
   ,"shared_memory"              //name
   ,read_only                    //read-only mode
   };
```

---
template: plain
header: ##### Retrieving Adress and Size

Once a shared memory object **`shm_obj`** is created or opened, its address (and
also its size) needs to be determined. This can also be done only for a smaller
part (segment) of the whole mappable **`shm_region`**:
```
    …
    std::size_t ShmSize = ...

    //Map the second half of the memory
    boost::interprocess::mapped_region shm_region
       {shm_obj                  //Memory-mappable object
       ,read_write               //Access mode
       ,ShmSize/2                //Offset from the beginning of shm
       ,ShmSize-ShmSize/2        //Length of the region
       };

    //Get the address of the region
    region.get_address();

    //Get the size of the region
    region.get_size();;
    …
```

---
template: plain
header: ##### Returning Shared Memory

To avoid exhaustion of resources, shared memory not any longer in use needs to
be (explicitely) returned.

Most elegantly this can be done following the RAII idiom, wrapping the static
`…::remove` in the destructor of a helper type:
```
struct shm_remove {
    using boost::interprocess::shared_memory_object;
    ~shm_remove() {
        shared_memory_object::remove("shared memory");
    }
};
```

A helper object of that type (`shm_remove`) is then defined inside the code
block that controls the life-time of the shared memory object which has been
named `"shared memory"`.._[]
 
.N.center[
[
Click here for fleshed-out example code from the Boost Documentation.
](http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/sharedmemorybetweenprocesses.html#interprocess.sharedmemorybetweenprocesses.sharedmemory.shared_memory_a_simple_example)
]

.F[:
This name can be chosen freely but must of course be the same name that had been
used when the shared memory was initially created.
]


---
template: plain
header: ##### Anonymous Shared Memory

While the shared memory in the previous examples had a name by which it was
indentified, also anonymous shared memory is supported:._[]
```
    …
    //Create an anonymous shared memory segment with size 1000
    mapped_region region(anonymous_shared_memory(1000));

    //Write all the memory to 1
    std::memset(region.get_address(), 1, region.get_size());

    //The segment is unmapped when "region" goes out of scope
    …
```

.N.center[
[
Click here for fleshed-out example code from the Boost Documentation.
](http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/sharedmemorybetweenprocesses.html#interprocess.sharedmemorybetweenprocesses.sharedmemory.anonymous_shared_memory)
]

.F[:
This is typically useful only in processes having a parent-child relationship
with each other or for direct or indirect children of the same parent, who then
is responsible to prepare the shared memory for its offspring.
]

---
name: memory_mapped_files
header: ##### OS-specific Variants of Shared Memory

Depending on the OS two other forms of shared memory may be supported:

* [Native Windows Shared Memory](http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/sharedmemorybetweenprocesses.html#interprocess.sharedmemorybetweenprocesses.sharedmemory.windows_shared_memory)
   or
* [Unix System V Shared memory](http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/sharedmemorybetweenprocesses.html#interprocess.sharedmemorybetweenprocesses.sharedmemory.xsi_shared_memory)

---
template: plain
name: memory_mapped_files
header: #### Memory-Mapped Files

[Boost Documentation]: http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/sharedmemorybetweenprocesses.html#interprocess.sharedmemorybetweenprocesses.mapped_file

Memory mapped files are much like shared memory as described before, with the
content being also present and accessible in the file system.

The [Boost Documentation] list the following advantages:

* Uniform resource use. Files and memory can be treated using the same
  functions.
* Automatic file data synchronization and cache from the OS.
* Reuse of C++ utilities (STL containers, algorithms) in files.
* Shared memory between two or more applications.
* Allows efficient work with a large files, without mapping the whole file into
  memory
* If several processes use the same file mapping to create mapped regions of a
  file, each process' views contain identical copies of the file on disk.

.N.center[
[
Click here for fleshed-out example code from the Boost Documentation.
](http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/sharedmemorybetweenprocesses.html#interprocess.sharedmemorybetweenprocesses.mapped_file.mapped_file_a_simple_example)
]

---
template: plain
name: various_synchronization
header: #### Various Synchronization Mechanisms

* Supported are:
  * [Semaphores](#boost_ipc_semapores) both,
    * [in a named variant](#boost_ipc_named_semaphores)
    * [and a unnamed one](#boost_ipc_unnamed_semaphores)
  * [Ordinary Mutexes](#boost_ipc_ordinary_mutexes)
  * [Upgradable Mutexes](#boost_ipc_upgradable_mutexes)
  * [Condition variables](#boost_ipc_condition_variables)

.N[
Note that the named variants need **not** be placed in shared memory to make
them accessible for several processes.
]

.F[:
Similar to UNIX/Windows sem_open/CreateSemaphore API in shared memory and memory
mapped files.
]

---
template: plain
name: boost_ipc_semaphores
header: ##### Basics of Semaphores

Basically Semaphores are

* created with some arbitrary start value,
* and have
  * a `wait()`-operation that
    * decrements the current value if it is positive,
    * otherwise suspends the calling process or thread;
  * a `post()`-operation that increments the current value.

Essential to understand this as **Synchronization Mechanism** is that

* the *current value* of a semaphore reflects
  * "the number or resources availabe"
* *waiting* for a semaphore means to
  * either "take away one resource" (if any is still available)
  * or "patiently stand in line" (until one becomes available)
* *posting* means to
  *return a resource* (for being stored or taken by someone else).

---
template: plain
name: boost_ipc_named_semaphores
header: ##### Synopsis of Named Semaphores

Similar to shared memory the named variant of a semaphore needs to be created
(once) before it can be opened (may times) and may (finally) be removed with
a static member function.

```
class named_semaphore {
public:
    named_semaphore(create_only_t, const char *, unsigned int, 
                    const permissions & = permissions());
    named_semaphore(open_or_create_t, const char *, unsigned int, 
                    const permissions & = permissions());
    named_semaphore(open_only_t, const char *);
    ~named_semaphore();
    static bool remove(const char *);
    void post();
    void wait();
    bool try_wait();
    bool timed_wait(const boost::posix_time::ptime &);
};
```

The different variants of the `wait()`-operation allow to chose between waiting
indefinitely or receiving a failure indication.._[]

.F[:
Either immediately o after a grace period (= timeout).
]

---
template: plain
name: boost_ipc_unnamed_semaphores
header: ##### Example for Unnamed Semaphores

Example programs tend to be beyond trivial, so the following only highlights the
common part of "Client and Server" example:._[]

```
struct shared_memory_buffer {
    //Data items exchanged between server and client
    enum { NumItems = 10 };
    int items[NumItems]; //Items to fill

    //Semaphores to protect and synchronize access
    using boost::interprocess::interprocess_semaphore;
    interprocess_semaphore mutex, nempty, nstored;

    //Constructor
    shared_memory_buffer()
        : mutex(1), nempty(NumItems), nstored(0)
    {}
};
```

.N.center[
[
Click here for fleshed-out example code from the Boost Documentation.
](http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/synchronization_mechanisms.html#interprocess.synchronization_mechanisms.semaphores.semaphores_anonymous_example)
]

.F[:
In the full example code the server (sending data) is second (after the common
data structure – as shown above) and the client (receiving data) is third.
]

---
template: plain
name: boost_ipc_ordinary_mutexes
header: #### Basics of Mutexes

The word *Mutex* is an artificial construct that can be understood as the
contraction of the two words "mutual execution".

Mutexes are quite similar to [Semaphores](#boost_ipc_semapores) but have act –
less general that semaphores – in a "boolean" way:

* A mutex represents a resource
  * that **either is**
  * **or is not** available.
* It always starts "unlocked" (= resource available),
  * can subsequently be locked and
  * unlocked again (any number of times).

.N[
If an attempt as made to lock a mutex that is already locked, the thread or
process trying to do so is suspended._[] until the mutex is unlocked.
]

Of course, if there are several threads or processes waiting for the same
(locked) mutex **only one** will be resumed.

.F[:
Depending on which variant of the `lock()`-operation is tried there may also be
a failure indication, immediately or after a specified grace period (= timeout).
]

---
template: plain
header: ##### Example for Unnamed Mutex

```
struct shared_memory_log {
    //Data items exchanged between server and client
    enum { NumItems = 100 }; enum { LineSize = 100 };
    char items[NumItems][LineSize];
    int current_line;
    bool end_a, end_b;

    //Mutex to protect access to the queue
    boost::interprocess::interprocess_mutex mutex;

    //Constructor
    shared_memory_log()
        :  current_line(0),  end_a(false),  end_b(false)
    {}
};
```

.N.center[
[
Click here for fleshed-out example code from the Boost Documentation.
](http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/synchronization_mechanisms.html#interprocess.synchronization_mechanisms.mutexes.mutexes_anonymous_example)
]

.F[:
In the full example code the server (sending data) is second (after the common
data structure – as shown above) and the client (receiving data) is third.
]


---
template: plain
name: boost_ipc_upgradable_mutexes
header: ##### Sharable vs. Upgradable Mutexes

Via *Sharable* and *Upgradable* Mutextes *Multiple Readers/Single Writer*
locking schemes can be implemented:

* Any number of **Readers** may acquire a shared lock  
  – as long as there is no concurrent **Writer**.

* Any **Writer** may acquire an exclusive lock  
  – as long as there are no readers.

* Any Reader may upgrade a shared lock into an exclusive lock  
  – as long as there are no other Readers (holding a shared lock).

For failing attempts to lock (or upgrade) it may be chosen whether this should
result in
* an exception thrown immediately or after a grace period (timeout),
* or the request should wait unlimited time until it can be granted

.N.center[
Beware of potential deadlocks for badly crafted locking attempts.._[]
]

.F[:
In general the use of timeouts will help to avoid deadlocks, but there may
still be livelocks causing starvation or at least sub-optimal performance.
]

---
template: plain
name: boost_ipc_scoped_locks
header: ##### Scoped Locks vs. Plain Mutexes

While Plain Mutexes have

* seperate `lock()`
* and `unlock()`

operations which must always be used symmetrically.

Scoped Locks apply the RAII idiom, i.e. they unlock automatically when the
control flow leaves the code block guarded that way.

.N.center[
[
Click here for fleshed-out example code from the Boost Documentation.
](http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/synchronization_mechanisms.html#interprocess.synchronization_mechanisms.mutexes.mutexes_scoped_lock)
]

---
template: plain
name: boost_ipc_condition_variables
header: ##### Condition Variables

Condition Variables

* combine Mutexes
  * protecting the integrity of some shared data structure

* with Rendezvous Points
  * on which a communication partner can wait for its counterpart
  * without consuming CPU cycles – i.e. **no busy waiting**

.N[
Condition variables are especially suited for Consumer-/Producer-Scenarios, when
the parts – which may be arrange in a "1:1" or a "M:N" configuration – are
connected via some buffer of bounded size.
]

---
template: plain
header: ##### Example for Unnamed Condition Variables

```
struct trace_queue {
    //Data items exchanged between server and client
   enum { LineSize = 100 };
   char   items[LineSize];
   bool message_in;

   //Mutex to protect access to the queue
   boost::interprocess::interprocess_mutex mutex;
   //Condition to wait when the queue is empty
   boost::interprocess::interprocess_condition cond_empty;
   //Condition to wait when the queue is full
   boost::interprocess::interprocess_condition cond_full;

   //Constructor
   trace_queue()
      :  message_in(false)
   {}
};
```

.N.center[
[
Click here for fleshed-out example code from the Boost Documentation.
](http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/synchronization_mechanisms.html#interprocess.synchronization_mechanisms.mutexes.mutexes_anonymous_example)
]

.F[:
In the full example code the server (sending data) is second (after the common
data structure – as shown above) and the client (receiving data) is third.
]

---
template: plain
header: ##### Example for Unnamed Condition Variables (cont.)

The essential feature here is that when

* one communication partner **needs to wait**
  * it must already hold the mutex
  * which gets implicitly released when waiting starts
* but is automatically re-acquired when waiting ends

(The following page shows two very "symmetrically structure" excerpts, one
from the sending end and one from the receiving end, nicely demonstrating
the "ping-pong" game going on.

.N[
When reviewing the two code fragments on the next page, be sure to understand
the crucial role of the `mutex`.._[]
]

.F[:
To have the `mutex`-member in the shared data structure is essential as
otherwise there would be race condition when testing and (re-) setting the
member `message_in`!  
To **unlock** that mutex while waiting – which is the implicit behaviour for
a condition variable – is also essential as otherwise the condition waited
for could never become true!
]

---
template: plain
header: ##### Example for Unnamed Condition Variables (cont.)

Again taken from the Boost Documentation (with some editing._[]):

```
    //Sending side (can progress when space is available)
    …
    scoped_lock<interprocess_mutex> lock(data->mutex);
    while (data->message_in)
         data->cond_empty.wait(lock);
    … // store message into buffer
    data->message_in = true;
    data->cond_full.notify_one();
    …
```

```
    //Receiving side (can progress when data is available)
    …
    scoped_lock<interprocess_mutex> lock(data->mutex);
    while (!data->message_in)
         data->cond_full.wait(lock);
    … // retrieve message from buffer
    data->message_in = false;
    data->cond_empty.notify_one();
    …
```

.F[:
Compared to the example code as shown in the Boost Documentation the names of
the two condition variables are used switched as it seams to better express
their purpose.
]

---
template: plain
name: file_locking
header: #### File Locking

---
template: plain
name: relative_pointers
header: #### Relative Pointers

http://www.boost.org/doc/libs/1_63_0/doc/html/interprocess/offset_ptr.html

---
template: plain
name: message_queues
header: #### Message Queues


</textarea>
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
<!-- ::::::::::::::::::::: )-: ereh TNETNOCLAER fo dne :::::::::::::::::::: -->
<!-- :::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::: -->
    <script src="remark.min.js" type="text/javascript">
    </script>
    <script type="text/javascript">
      var slideshow = remark.create({ highlightLanguage: 'cpp', highlightStyle: 'docco' });
    </script>
  </body>
</html>
